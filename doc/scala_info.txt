*scalainfo.txt*	      Scala Reference and Information	        Feb 21, 2011

Author:    Derek Wyatt <derek@{my first name}{my last name}.org>

Copyright: (c) 2011 by Derek Wyatt
           No license implied... use it for whatever tickles your particular
           fancy.  A lot of these examples have come from the book,

               "Programming in Scala 2nd Edition" by
                    Martin Odersky
                    Lex Spoon
                    Bill Venners

            You can purchase the book from Artima at:

                http://www.artima.com/shop/programming_in_scala_2ed

            I highly recommend it - you'll get a lot more out of reading that
            than reading this.

==============================================================================
0. Contents                                           *scala* *scala-contents*
------------------------------------------------------------------------------

  1. Built-in Control Structures.............: |scala-built-in-control|
    1.1 "if".................................: |scala-if|
    1.2 "while" and "do/while"...............: |scala-while|
    1.3 "for"................................: |scala-for|
      1.3.1 Terminology......................: |scala-for-terminology|
      1.3.2 "for" and Pattern Matching.......: |scala-for-and-patterns|
      1.3.3 Translating "for" Expressions....: |scala-for-translation|
    1.4 Exceptions...........................: |scala-exceptions|
    1.5 Match Expression.....................: |scala-match|
  2. The "apply" Function....................: |scala-apply-function|
  3. Classes.................................: |scala-classes|
    3.1 Parameter List.......................: |scala-class-parameters|
    3.2 Parametric Fields....................: |scala-parametric-fields|
    3.3 Primary Constructor..................: |scala-primary-constructor|
    3.4 Superclass Constructor...............: |scala-superclass-constructor|
    3.5 Finality.............................: |scala-finality|
    3.6 Class Hierarchy......................: |scala-hierarchy|
    3.7 Ugly Private Constructors............: |scala-ugly-private-ctors|
    3.8 Variables............................: |scala-variables|
  4. Traits..................................: |scala-traits|
    4.1 scala.math.Ordered...................: |scala-ordered-trait|
    4.2 Stackable Modifications..............: |scala-stackable-traits|
      4.2.1 Linearization....................: |scala-linearization|
      4.2.2 Stackability.....................: |scala-stacking|
    4.3 IteratbleLike........................: |scala-iterable-like|
      4.3.1 zip..............................: |scala-zip|
  5. Objects.................................: |scala-objects|
  6. Abstract-ness...........................: |scala-abstractness|
    6.1 Initializing Abstract-ness...........: |scala-initializing-abstractness|
    6.2 Abstract Types.......................: |scala-abstract-types|
    6.3 Structural Typing....................: |scala-structural-typing|
  7. Functions...............................: |scala-functions|
    7.1 Single Statements....................: |scala-single-stmt-functions|
    7.2 Parameterless Methods................: |scala-parameterless-methods|
    7.3 Procedures...........................: |scala-procedures|
    7.4 Anonymous Functions..................: |scala-anonymous-functions|
    7.5 Functions as Parameters..............: |scala-functions-as-params|
    7.6 Local Functions......................: |scala-local-functions|
    7.7 Assignemtn to val/var................: |scala-functions-as-type|
    7.8 Partial Functions....................: |scala-partial-function|
    7.9 Closures.............................: |scala-closures|
    7.10 Currying............................: |scala-currying|
    7.11 Loan Pattern........................: |scala-loan-pattern|
    7.12 "By Name" Parameters................: |scala-byname-params|
    7.13 Repeated Parameters.................: |scala-repeated-params|
    7.14 Named Arguments.....................: |scala-named-arguments|
    7.15 Default Parameter Values............: |scala-default-arguments|
    7.16 Tail Recursion......................: |scala-tail-recursion|
  8. Predef..................................: |scala-predef|
  9. Types...................................: |scala-types|
    9.1 Option...............................: |scala-option|
      9.1.1 Option as Monad..................: |scala-option-monad|
      9.1.2 Option Cheat Sheet...............: |scala-option-cheat-sheet|
    9.2 Array................................: |scala-array|
    9.3 Range................................: |scala-range|
    9.4 List.................................: |scala-list|
      9.4.1 And Pattern Matching.............: |scala-list-and-patterns|
      9.4.2 Various Operations...............: |scala-list-operations|
      9.4.3 Construction Options.............: |scala-list-construction|
    9.5 ArrayBuffer..........................: |scala-array-buffer|
    9.6 String...............................: |scala-string|
      9.6.6 StringOps........................: |scala-stringops|
    9.7 Sets and Maps........................: |scala-sets-and-maps|
    9.8 Regular Expressions..................: |scala-regular-expressions|
      9.8.1 Methods on Regex.................: |scala-regex-methods|
      9.8.2 Pattern Matching.................: |scala-regex-pattern-matching|
 10. Packages and Access Modifiers...........: |scala-packages|
   10.1 Access Rules.........................: |scala-access|
   10.2 Packaging............................: |scala-packaging|
 11. Type Parameterization...................: |scala-generics|
   11.1 Type Variance........................: |scala-variance|
     11.1.1 Type Variance Explained..........: |scala-variance-explained|
   11.2 Lower Bound..........................: |scala-lower-bound|
   11.3 Upper Bound..........................: |scala-upper-bound|
   11.4 Manifest Stuff.......................: |scala-manifest|
 12. Pattern Matching........................: |scala-pattern-matching|
   12.1 Case Classes.........................: |scala-case-classes|
   12.2 Basic Pattern Match..................: |scala-basic-pattern-match|
   12.3 Comparison to Java Switch............: |scala-match-vs-switch|
   12.4 Wildcards............................: |scala-match-wildcards|
   12.5 Constant Patterns....................: |scala-constant-patterns|
   12.6 Variable Patterns....................: |scala-variable-patterns|
   12.7 Constructor Patterns.................: |scala-constructor-patterns|
   12.8 Typed Patterns.......................: |scala-typed-patterns|
   12.9 Type Erasure.........................: |scala-type-erasure|
   12.10 Variable Binding....................: |scala-variable-binding|
   12.11 Pattern Guards......................: |scala-pattern-guards|
   12.12 Pattern Overlaps (Depth)............: |scala-pattern-overlaps|
   12.13 Sealed Classes......................: |scala-sealed-classes|
   12.14 Patterns in Variable Definitions....: |scala-patterns-in-variables|
   12.15 Patterns and Partial Functions......: |scala-patterns-and-partials|
   12.16 Extractors..........................: |scala-patterns-extractors|
     12.16.1 Deeper Extracting...............: |scala-deeper-extracting|
     12.16.2 Variable Arg Extractors.........: |scala-variable-arg-extractors|
 13. Language Extensibility..................: |scala-extensibility|
   13.1 Implementing loop/unless.............: |scala-loop-unless|
 14. Functional Programming..................: |scala-functional|
   14.1 Printing a Matrix....................: |scala-functional-matrix|
 15. Testing.................................: |scala-testing|
 16. Miscellaneous...........................: |scala-miscellaneous|
   16.1 Unicode..............................: |scala-unicode|
   16.2 Working with Collections.............: |scala-collection-tips|
   16.3 Implicit Conversions.................: |scala-implicit-conversions|
     16.3.1 Converting on the Source.........: |scala-implicit-source-convert|
     16.3.2 Converting on the Receiver.......: |scala-implicit-receiver-convert|
     16.3.3 Implicit Parameters..............: |scala-implicit-parameters|
     16.3.4 Implicits and Rules..............: |scala-implicit-rules|
     16.3.5 Debugging Implicits..............: |scala-implicit-debugging|

==============================================================================
1. Built-in Control Structures                  *scala-built-in-control* {{{1
------------------------------------------------------------------------------

1.1 "if"                                                      *scala-if* {{{2
------------------------------------------------------------------------------

The {if} control structure is pretty standard except for one thing: {if}
statements return values.  This makes them much more useful than what I'm used
to.  At the minimum, it allows us to eliminate the need for a ternary
operator, because the {if/else} pair does that for us.
!sc!
    if (predicate) doTrue else doFalse
!/sc!
And you can then assign the result to a {val} or {var}:
!sc!
    val func = if (args.length == 2) "Execution: (" + args.mkstring(", ") + ")"
               else "Parse: " + args.mkstring(", ")
!/sc!
1.2 "while" and "do/while"                                 *scala-while* {{{2
------------------------------------------------------------------------------

Generally, if you've got these things in your code, you've probably got a
problem, but Scala takes a pragmatic approach to things and if you really have
a need for a more imperative style as this indicates then go for it.

{while} and {do/while} do not return values as the {if} control structure
does.  As such, you're pretty much bound to deal with side effects when you're
using a looping construct like this, and that's why they're frowned upon -
generally a side-effect-free mechanism is to be preferred.

It's pretty obvious stuff:
!sc!
    var line = readLine()
    while (line != "") {
        println("Read: "+ line)
        line = readLine()
    }
!/sc!
And the (better, for this particular problem) {do/while} loop:
!sc!
    var line = ""
    do {
        line = readLine()
        println("Read: "+ line)
    } while (line != "")
!/sc!
1.3 "for"                                                    *scala-for* {{{2
------------------------------------------------------------------------------

The {for} control structure is a big deal; it's not just your standard
"looping" mechanism but more of the swiss-army knife of Scala's control
structures.  In its simplest form it's a basic {generator}.
!sc!
    val filesHere = (new java.io.File(".")).listFiles
    for (file <- filesHere)
        println(file)
!/sc!
The {file} parameter above is a {val}, even though it's not explicitly stated;
and this makes sense due to the fact that it's about to change on the next
iteration and thus it will be lost and tossed out of scope.

We can use it to filter input to the generator:
!sc!
    scala> for (i <- 1 to 10 if i %2 == 0) println(i) 
    2
    4
    6
    8
    10
!/sc!
And the filtering can be nested:
!sc!
    scala> for (i <- 1 to 100
         |      if i % 3 == 0
         |      if i % 4 == 0
         | ) println(i) 
    12
    24
    36
    48
    60
    72
    84
    96
!/sc!
And you can have multiple {<-} clauses that let you get some nested loops,
such as:
!sc!
    scala> for (digitA <- Array(1, 2, 3, 4, 5, 6)
         |      if digitA % 2 == 0; // **** NOTE the semicolon ****
         |      digitB <- Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
         |      if digitB % 3 == 0
         |      ) println(digitA.toString + digitB.toString)
    23
    26
    29
    43
    46
    49
    63
    66
    69
!/sc!
                                                     *scala-for-alternate*
Scala provides for an alternate syntax for {for} expressions with respect to
the arguments.  You can use a set of curly braces if you want.  I'm not sure
that it's such a big deal, but should things look weird with parentheses, we
can opt to use curlies.
!sc!
    scala> for { digitA <- Array(1, 2, 3, 4, 5, 6)
         |       if digitA % 2 == 0; // **** NOTE the semicolon ****
         |       digitB <- Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
         |       if digitB % 3 == 0
         |     } println(digitA.toString + digitB.toString)
    23
    26
    29
    43
    46
    49
    63
    66
    69
!/sc!
                                                             *scala-yield*
{for} also carries with it, the {yield} keyword we get a really neat
generator.
!sc!
    scala> val evens = for (i <- 1 to 10 if i % 2 == 0) yield i
    evens: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10)
!/sc!
Note: strictly speaking, the above is performed much more functionally, and
more clearly with the following:
!sc!
    scala> val evens = (1 to 10) filter (_ % 2 == 0)
    evens: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10)
!/sc!

1.3.1 Terminology                                *scala-for-terminology* {{{3
------------------------------------------------------------------------------

generator                                               *scala-for-generator*

    A generator is of the form:
!sc!
        pat <- expr
!/sc!
    Typically {expr} returns a list of some sort, but this can be generalized.
    {pat} gets matched one-by-one against all elements of that list.  If the
    match succeeds, the variables in the pattern get bound to the
    corresponding parts of the element.  If the match fails, no {MatchError}
    is thrown.  Instead, the element is simply discarded from the iteration.

    In the most common case, the pattern {pat} is just a variable {x}, as in
    "x <- expr".  In that case, the variable {x} simply iterates over all
    elements return by {expr}.

    Every {for} expression starts with a generator.  If there are several
    generators in a {for} expression, later generators vary more rapidly
    than earlier ones.
          
definition                                             *scala-for-definition*

    A definition is of the form:
!sc!
        pat = expr
!/sc!
    This is the same as a val definition:
!sc!
        val pat = expr
!/sc!
filter                                                     *scala-for-filter*

    A filter is of the form:
!sc!
        if expr
!/sc!
    Here, expr is an expression of type {Boolean}.  The filter drops from the
    iteration all elements for which {expr} returns {false}.


1.3.2 "for" and Pattern Matching                *scala-for-and-patterns* {{{3
------------------------------------------------------------------------------

We discuss the intracacies of |scala-pattern-matching| later but they are
pretty tightly integrated with {for} so we need to deal with them here a bit.

{for} uses pattern matching in its operation and is pretty resilient in the
face of |scala-option| types.
!sc!
    scala> val results = List(Some("apple"), None, Some("orange"))
    results: List[Option[java.lang.String]] =
                List(Some(apple), None, Some(orange))

    scala> for (Some(fruit) <- results) println(fruit)
    apple
    orange
!/sc!
See how we were matching on "Some(fruit)" and "None" didn't match so it never
made its way into the {for} expression?  Pretty keen stuff.


1.3.3 Translating "for" Expressions              *scala-for-translation* {{{3
------------------------------------------------------------------------------

Translating {for} Expressions with One Generator
!sc!
        for (x <- expr1) yield expr2
!/sc!
    translates to
!sc!
        expr1.map(x => expr2)
!/sc!

Translating {for} Expressions Starting with a Generator and a Filter
!sc!
        for (x <- expr1 if expr2) yield expr3
!/sc!
    translates to
!sc!
        for (x <- expr1 withFilter (x => expr2)) yield expr3
!/sc!
    translates to
!sc!
        expr1 withFilter (x => expr2) map (x => expr3)
!/sc!

Translating {for} Expressions Starting with Two Generators
!sc!
        for (x <- expr1; y <- expr2; seq) yield expr3
!/sc!
    Assume that {seq} is an arbitrary sequence of generators, definitions and
    filters.  In fact, {seq} might also be empty, and in that case there would
    not be a semicolon after {expr2}.  The translation scheme stays the same
    in each case.  The {for} expression above is translated to an application
    of {flatMap}:
!sc!
        expr1.flatMap(x => for (y <- expr2; seq) yield expr3)
!/sc!

1.4 Exceptions                                        *scala-exceptions* {{{2
------------------------------------------------------------------------------

This is a lot like Java, but has some significant differences.

a. {throw} can be treated as an expression because the act of throwing an
   exception returns an instance of {Nothing}.  Due to Scala's type structure,
   {Nothing} is a valid value for any other object in Scala.
b. {catch} clauses use |scala-pattern-matching| to do what they do
c. You do not have to catch exceptions
d. You do not need to declare the exceptions you throw

The consequence of {a} is that the following is beautifully deterministic:
!sc!
    val half = if (n % 2 == 0)
        n/2
    else
        throw new RuntimeException("n must be even")
!/sc!
I'm a little foggy on the details, but in general, although the exception is
going to kill the current execution state, the return value from the throw is
actually a deterministic value of {Nothing}.

                                                    *scala-exception-catching*

You catch exceptions in a single clause and pattern match on what you caught.
This is pretty damn cool:
!sc!
    import java.io.FileReader
    import java.io.FileNotFoundException
    import java.io.IOException

    try {
        val f = new FileReader("input.txt") // Use and close file
    } catch {
        case ex: FileNotFoundException => // Handle missing file
        case ex: IOException => // Handle other I/O error
    }
!/sc!
                                                         *scala-finally-block*

And we've got the standard {finally} block from Java as well, which we use in
general to implement the |scala-loan-pattern|.  Things are a bit interesting
with the {finally} block, though; you've got to worry about what to do when
you want to yield a value.  The try/catch/finally block yields a value in
Scala, but what do you do when you're in the {finally} block?

Check out the weirdness:
!sc!
    scala> def f(): Int = try {
         |     return 1
         | } finally {
         |     return 2
         | }
    f: ()Int
    
    scala> f
    res0: Int = 2
!/sc!
That makes sense, the finally block is the last block to be executed, so
you're good to go.  However...
!sc!
    scala> f
    res1: Int = 2
    
    scala> def g(): Int = try {
         |     1
         | } finally {
         |     2
         | }
    g: ()Int
    
    scala> g
    res2: Int = 1
!/sc!
The idea is that {try} and {catch} return values, but the {finally} block is
the last one executed.  So, if you're going to explicitly use {return} to
return a value then the {finally} block is going to make it happen.
!sc!
    scala> def h(): Int = try {       
         |     1                          
         | } catch {
         |     case e: Exception =>       
         |         2
         | } finally {
         |     3
         | }
    h: ()Int
    
    scala> h
    res0: Int = 1
!/sc!
Makes sense.  Everything went well so we got a "1".  Now, let's throw an
exception and see what happens:
!sc!
    scala> def h(): Int = try {       
         |     throw new Exception("oops")
         | } catch {
         |     case e: Exception =>       
         |         2
         | } finally {
         |     3
         | }
    h: ()Int
    
    scala> h
    res0: Int = 2
!/sc!
Again, makes sense.  The {catch} block is run into and it returns a value, and
that value happens to be "2".  In both cases, the finally block has been
executed but that's not where the natural return comes from, so it's all
deterministic and makes good sense.


1.5 Match Expression                                       *scala-match* {{{2
------------------------------------------------------------------------------

The match expression allows us to use |scala-pattern-matching| to figure out
what kind of data we're dealing with and move on it.
!sc!
    val firstArg = if (!args.isEmpty) args(0) else ""
    val friend = firstArg match {
        case "salt"  => "pepper"
        case "chips" => "salsa"
        case "eggs"  => "bacon"
        case _       => "huh?"
    }
    println(friend)
!/sc!

==============================================================================
2. The "apply" Function                           *scala-apply-function* {{{1
------------------------------------------------------------------------------

Every instantiated class has an {apply} function on it.  This is equivalent to
the function operator in C++ in that the Scala compiler will divert a call to
the () function to the {apply} function.  Various classes will override the
definition of the apply function in order to do what they do.  An obvious one
here is in the Array class:
!sc!
    scala> val greetStrings: Array[String] = new Array[String](3)
    greetStrings: Array[String] = Array(null, null, null)
    
    scala> greetStrings(0) = "Hello"
    scala> greetStrings(1) = ", "   
    scala> greetStrings(2) = "world!\n"
!/sc!
In the case of a |scala-partial-function| {apply} forwards the call into the
embedded function:
!sc!
    scala> def sum(a: Int, b: Int, c: Int) = a + b + c
    sum: (a: Int,b: Int,c: Int)Int
    
    scala> val partial = sum _
    partial: (Int, Int, Int) => Int = {function3}

    partial.apply(1, 2, 3) == partial(1, 2, 3)
    res1: Boolean = true
!/sc!

==============================================================================
3. Classes                                               *scala-classes* {{{1
------------------------------------------------------------------------------

Classes are much simpler to define in Scala than any other language I've seen.

3.1 Parameter List                             *scala-class-parameters* {{{2
------------------------------------------------------------------------------

The parameter list becomes privately available after the class has been
instantiated.
!sc!
    scala> class MyClass(a: Int, b: String) {
         |     override def toString = "a: " + a + ", b: " + b
         | }
    defined class MyClass
    
    scala> val = new MyClass(42, "Forty-Two")
    myobj: MyClass = a: 42, b: Forty-Two
!/sc!

3.2 Parametric Fields                         *scala-parametric-fields* {{{2
------------------------------------------------------------------------------

Often times there's a field or two in the class and a derivation of that class
may want to override them.  The usual way to do this in other languages is to
do this:
!sc!
    scala> abstract class BaseClass {
         |     val attribute: String
         | }
    defined class BaseClass

    scala> class DerivedClass(attr: String) {   
         |     val attribute  = attr
         | }
    defined class DerivedClass
!/sc!
However, this doesn't need to be so verbose in Scala.  We can override the
{attribute} member directly in the class declaration:
!sc!
    scala> abstract class BaseClass {
         |     val attribute: String
         |     override def toString = "String: " + attribute
         | }
    defined class BaseClass

    scala> class DerivedClass(override val attribute: String) extends BaseClass
    defined class DerivedClass

    scala> val obj = new DerivedClass("hithere")
    obj: DerivedClass = String: hithere
!/sc!

3.3 Primary Constructor                     *scala-primary-constructor* {{{2
------------------------------------------------------------------------------

Scala stipulates that all classes have a primary constructor.  What's more any
auxillary constructors must call the primary constructor.  Failure to do so
will result in a compiler error.
!sc!
    scala> class MyClass(a: Int, b: String) {
         |
         |     def this() {
         |          this(42, "Forty-Two")
         |     }
         |
         |     override def toString = "a: " + a + ", b: " + b
         |
         | }
    defined class MyClass
    
    scala> val myobj = new MyClass                        
    myobj: MyClass = a: 42, b: Forty-Two
!/sc!

3.4 Superclass Constructor               *scala-superclass-constructor* {{{2
------------------------------------------------------------------------------

The constructor of the superclass is called in the class specification, not
from within one of its constructors, as we would see in other languages.  Say
you have the following base class declaration:
!sc!
    scala> class BaseClass(attribute: String) {
         |     override def toString = "attribute: " + attribute
         | }
    defined class BaseClass
    
    scala> class DerivedClass extends BaseClass("Hard Coded")
    defined class DerivedClass
    
    scala> val obj = new DerivedClass
    obj: DerivedClass = attribute: Hard Coded
!/sc!
Here we've passed in the {attribute} argument to the {BaseClass} inside the
{extends} clause of the specification of the DerivedClass.


3.5 Finality                                           *scala-finality* {{{2
------------------------------------------------------------------------------

You can use the {final} keyword to do a couple of things.  If you want to
declare that a method cannot be overridden further then we can declare it as
{final}.
!sc!
    scala> class MyClass {
         |      override def toString = "MyClass is it"
         | }
    defined class MyClass
    
    scala> class MyDerivedOne extends MyClass {
         |      final override def toString = "MyDerivedOne is it"
         | }
    defined class MyDerivedOne
    
    scala> class MyDerivedTwo extends MyDerivedOne {              
         |     final override def toString = "MyDerivedTwo is it"
         | }
    {console}:8: error: overriding method toString in class MyDerivedOne of type ()java.lang.String;
     method toString cannot override final member
               final override def toString = "MyDerivedTwo is it"
!/sc!
You can also use it to ensure that a class not be derived further:
!sc!
    scala> final class NoMorePlease
    defined class NoMorePlease
    
    scala> class MaybeOneMore extends NoMorePlease
    {console}:6: error: illegal inheritance from final class NoMorePlease
           class MaybeOneMore extends NoMorePlease
!/sc!

==============================================================================
3.6 Class Hierarchy                                    *scala-hierarchy* {{{2
------------------------------------------------------------------------------

Scala has a class hierarchy that needs to be understood at its most basic
level.

                              {Any}
                               ^ ^
                               | |
         +---------------------+ +--------------------+
         |                                            |
     {AnyVal}                                     {AnyRef}

  Includes:                                    Includes:

    Unit                                         ScalaObject
    Boolean                                      Other "stuff"
    Char
    Double
    Float
    Long
    Int
    Short
    Byte

      ^              ^               ^                ^
      |              |               |                |
      +--------+-----+---------------+---+------------+
               |                         |
           {Nothing} ---------------> {Null}


3.7 Ugly Private Constructors                 *scala-ugly-private-ctors* {{{2
------------------------------------------------------------------------------

Because there is a must-have primary constructor, it's pretty tough to make it
private and not be obvious about it.  Let's say you want to privatize the
primary constructor but publicize another one; you might want to do this:
!sc!
    // The keyword 'private' below privatizes the primary constructor
    class Queue[T] private (
        private val leading: List[T],
        private val trailing: List[T]
    ) {
        // This is the public constructor
        this(elems: T*) = this(elems.toList, Nil)        

        private def mirror = {
            if (leading.isEmpty)
                new Queue(trailing.reverse, Nil)
            else
                this
        }

        def head = mirror.leading.head

        def tail = {
            val q = mirror
            new Queue(q.leading.tail, q.trailing)
        }

        def enqueue(x: T) = new Queue(leading, x :: trailing)
    }
!/sc!
There's another way to do this, if that seems to suck... We can hide the whole
damn thing inside the Queue object, expose it with a trait instead, and
present factory methods in the Queue object for construction purposes.
!sc!
    // This is what the world sees
    trait Queue[T] {
        def head: T
        def tail: Queue[T]
        def enqueue(x: T): Queue[T]
    }

    object Queue {
        // And this is what the world sees to create it
        def apply[T](xs: T*): Queue[T] = new QueueImpl[T](xs.toList, Nil)

        // And they need not ever even look at this thing
        private class QueueImpl[T](
            private val leading: List[T],
            private val trailing: List[T]
        ) extends Queue[T] {
            def mirror = {
                if (leading.isEmpty)
                    new QueueImpl(trailing.reverse, Nil)
                else
                    this
            }

            def head: T = mirror.leading.head

            def tail: QueueImpl[T] = {
                val q = mirror
                new QueueImpl(q.leading.tail, q.trailing)
            }

            def enqueue(x: T) =
                new QueueImpl(leading, x :: trailing)
        }
    }
!/sc!

3.8 Variables                                          *scala-variables* {{{2
------------------------------------------------------------------------------

Scala class / trait / object variables are much like properties in C# without
the hassle of the extraneous syntax.  The following definition:
!sc!
    trait AbstractTime {
        var hour: Int
        var minute: Int
    }
!/sc!
is equivalent to the following:
!sc!
    trait AbstractTime {
        def hour: Int
        def hour_=(x: Int)
        def minute: Int
        def minute_=(x: Int)
    }
!/sc!
So, the following is perfectly correct:
!sc!
    scala> class C {
         |     private[this] var hiddenVar = "hithere"
         |     def visible = hiddenVar
         |     def visible_=(x: String) = hiddenVar = x
         | }
    defined class C
    
    scala> val c = new C
    c: C = C@43e27370
    
    scala> c.visible
    res0: java.lang.String = hithere
    
    scala> c.visible = "what's up?"
    
    scala> c.visible               
    res1: java.lang.String = what's up?
!/sc!

==============================================================================

4. Traits                                                 *scala-traits* {{{1
------------------------------------------------------------------------------

Traits provide a very powerful {mixin} aspect to Scala.  They allow you to
make rich interfaces where pure interface implementation would force you (or
make it very difficult to do otherwise) create thin interfaces instead.

One would like to create interfaces with lots of strong methods and
functionality but when you do it with interfaces, you're forcing the
implementer to write code to realize those interfaces.  With traits, you can
create strong interfaces along with supporting logic and required data so that
the users that mix it in get a ton of stuff for free.

4.1 scala.math.Ordered                             *scala-ordered-trait* {{{2
------------------------------------------------------------------------------

One of the concrete examples in the Scala language is the {Ordered} trait in
{scala.math}.  By mixing this trait in, and implementing the {compare}
function you get {<}, {>}, {<=}, {>=} and {compareTo} for free.
!sc!
    trait Ordered[A] extends Comparable[A] {
        def < (that: A) : Boolean
        def <= (that: A) : Boolean
        def > (that: A) : Boolean
        def >= (that: A) : Boolean

        // This needs to be implemented
        def compare (that: A) : Int

        def compareTo (that: A) : Int 
    }
!/sc!

4.2 Stackable Modifications                     *scala-stackable-traits* {{{2
------------------------------------------------------------------------------

Traits provide a mechanism for altering class behaviour in a stackable
fashion.  You can mix in many different traits into a class and, depending on
how they override behaviour and make use of calls to {super}, those mixed in
traits can modify behaviour in a "stackable" fashion.

4.2.1 Linearization                                *scala-linearization* {{{3
------------------------------------------------------------------------------

The {mixin} capabilities of Scala can, on the surface, feel like multiple
inheritance but there are some big reasons why multiple inheritence doesn't
work for things like this and the main reason is because of {linearization}.
In order to understand which method overrides which, and how stacking can
work, there needs to be a deterministic algorithm for deciding on the
inheritance hierarchy.  Scala refers to this algorithm as linearization.

The algorithm is detailed and, apparently, decently complex but the rule of
thumb is that the ordering goes from right to left.  Given the following
inheritance structure:
!sc!
    class Animal
    trait Furry extends Animal
    trait HasLegs extends Animal
    trait FourLegged extends HasLegs
    class Cat extends Animal with Furry with FourLegged
!/sc!
The linearization for {Cat} gets evaluated in parts.  We start with {Animal}
and linearize it:

{Animal} -> {AnyRef} -> {Any}

The next part is to evaluate {Furry} with the caveat that we never duplicate a
class that has already been put into the linearization.

{Furry} -> {Animal} -> {AnyRef} -> {Any}

And we then move on to {FourLegged} and linearize it within the existing
linearization, staying true to the earlier caveat.

{FourLegged} -> {HasLegs} -> {Furry} -> {Animal} -> {AnyRef} -> {Any}

And finally we finish up with {Cat}.

{Cat} -> {FourLegged} -> {HasLegs} -> {Furry} -> {Animal} -> {AnyRef} -> {Any}


4.2.2 Stackability                                      *scala-stacking* {{{3
------------------------------------------------------------------------------

An example of stacking is to modify a "Integer Queue" with different behaviour
when putting more information into the queue.
!sc!
    abstract class IntQueue {
        def get(): Int
        def put(x: Int)
    }
!/sc!
With a basic implementation as follows:
!sc!
    import scala.collection.mutable.ArrayBuffer

    class BasicIntQueue extends IntQueue {
        private val buf = new ArrayBuffer[Int]
        def get() = buf.remove(0)
        def put(x: Int) { buf += x }
    }

!/sc!
Now we want to create some traits that allow us to modify the behaviour of the
push with different types of policies.
!sc!
    trait Doubling extends IntQueue {
        abstract override def put(x: Int) { super.put(2 * x) }
    }

    trait Incrementing extends IntQueue {
        abstract override def put(x: Int) { super.put(x + 1) }
    }

    trait Filtering extends IntQueue {
        abstract override def put(x: Int) {
            if (x >= 0) super.put(x)
        }
    }
!/sc!
Note the "abstract override".  That's one of the things that makes this work.
Normally if you're going to call {super} on an abstract class, you're screwed,
but Scala fixes this by allowing you to specify that you are specifically
overriding an abstract method.  When the class finally gets constructed, Scala
will resolve the lack of an implementation with the implementation that gets
mixed in.

So now we can mix this up and put it together:
!sc!
    scala> val q = new BasicIntQueue with Doubling
         |                           with Incrementing
         |                           with Filtering
    q: BasicIntQueue with Doubling
                     with Incrementing
                     with Filtering = $anon$1@14654dec
    
    // This one got filtered immediately
    scala> q.put(-1)
    
    // Got past the filter, then incremented, then doubled
    scala> q.put(0) 
    
    // Got past the filter, then incremented, then doubled
    scala> q.put(1)
    
    // Pulled out the first one that got through... the 2
    scala> q.get
    res0: Int = 2
    
    // Now we get the next one that got through... the 4
    scala> q.get
    res1: Int = 4
    
    // Nothing left, because we only put in two things
    scala> q.get
    java.lang.IndexOutOfBoundsException: 0
!/sc!

4.3 IteratbleLike                                  *scala-iterable-like* {{{2
------------------------------------------------------------------------------

4.3.1 zip                                                    *scala-zip* {{{3
------------------------------------------------------------------------------

The *zip()* function will create an object of the same base type as its
arguments (i.e. If you give it Arrays, it will create Arrays), that is the
combination of each one in a {Tuple}.
!sc!
    scala> val ary1 = Array(1, 2, 3, 4, 5)
    ary1: Array[Int] = Array(1, 2, 3, 4, 5)
    
    scala> val ary2 = Array("One", "Two", "Three", "Four", "Five")
    ary2: Array[java.lang.String] = Array(One, Two, Three, Four, Five)

    scala> ary1 zip ary2
    res0: Array[(Int, java.lang.String)] = Array((1,One),   (2,Two),
                                                 (3,Three), (4,Four),
                                                 (5,Five))
    
    scala> (ary1 zip ary2).foreach(println)
    (1,One)
    (2,Two)
    (3,Three)
    (4,Four)
    (5,Five)
!/sc!

==============================================================================
5. Objects                                               *scala-objects* {{{1
------------------------------------------------------------------------------

Scala Objects are singletons.  They provide perfect spots to hold factory
methods, constants, implicits, etc...

When an Object has the same name as an existing class, it is known as a
"companion" object and has access to the class' private data (and vice versa).
In order to achieve this, the companion object and its class must be defined
in the same source file.

One can see the use of a companion object and an object factory method
whenever you're constructing a List / Array / Map / etc...
!sc!
    scala> val list = List("One", "Two", "Three")
    list: List[java.lang.String] = List(One, Two, Three)
!/sc!
The List() method is on defined on the object and returns a new instance of a
List class.


==============================================================================
6. Abstract-ness                                    *scala-abstractness* {{{1
------------------------------------------------------------------------------

Due to Scala's flexibility, the concept of the "abstract" becomes much more
powerful.  There are a number of concepts in the abstract.
!sc!
    trait Abstract {
        // An abstract type alias
        type T

        // An abstract method definition
        def transform(x: T): T

        // An abstract value definition
        val initial: T

        // An abstract variable definition
        var current: T
    }
!/sc!
In order to create a concrete instantiation of the {Abstract} trait decleared
above, we must define all of the abstract members.
!sc!
    class Concrete extends Abstract {
        type T = String
        def transform(x: String) = x + x
        val initial = "hi"
        var current = initial
    }
!/sc!
                                             *scala-abstract-method-with-val*
You can implement an abstract method definition with concrete method or with a
value, assuming there are no arguments.  i.e. the following:
!sc!
    trait Abstract {
        def m: String
    }

    class Concrete {
        val m: String = "concrete value"
    }
!/sc!

6.1 Initializing Abstract-ness         *scala-initializing-abstractness* {{{2
------------------------------------------------------------------------------

Let's say you have the following:
!sc!
    trait RationalTrait {
        val numerArg: Int
        val denomArg: Int
    }
!/sc!
and you try to instantiate it into an anonymous class with the following:
!sc!
    new RationalTrait {
        val numerArg = 1
        val denomArg = 2
    }
!/sc!
This isn't the same as if you had a "real" class called {Rational} with a
primary constructor, the initialization of the fields would be different:
!sc!
    class Rational(numer: Int, denom: Int)

    val rat = new Rational(expr1, expr2)
!/sc!
The execution of {expr1} and {expr2} happen before the initialization of
{Rational}.  In the case of the anonymous class, the elements of the anonymous
class are initialized /after/ the {RationalTrait}.  This is a critical
difference.  In our case here, the {numerArg} and {denomArg} will be
initialized to default values ({0} in the case of the {Int}) and then when
you need the values, chances are they're going to be the default values and
not the "initialized" ones.

                                              *scala-pre-initialized-fields*
You can fix this up a bit with "pre-initialized fields".  You could do the
following:
!sc!
    scala> new {
         |         val numerArg = 1 * x
         |         val denomArg = 2 * x
         | } with RationalTrait
!/sc!
or
!sc!
    scala> object oneHalf extends {
         |     val numerArg = 1
         |     val denomArg = 2
         | } with RationalTrait
!/sc!
Syntactically this makes pretty decent sence, it would seem, since you're
indicating that you want this done /before/ the trait itself gets put
together.  But you can't do things like this:
!sc!
    scala> new {
         |         val numerArg = 1 * x
         |         val denomArg = this.numerArg * 2
         | } with RationalTrait
    {console}:9: error: value numerArg is not a member of object $iw
             val denomArg = this.numerArg * 2
!/sc!
                                                           *scala-lazy-vals*
This can also be done by using {lazy} values.  Lazy values are initialized
when they're first needed.  Thus, the "static" default initialization of a
value won't happen until the value is needed.  So, assuming that nobody needs
it until the "right" moment, the values will be what you intended.  The
problem, of course, is that this is a bit brittle against changes to the trait
/ class / object.  If someone starts using that value earlier than was
originally intended, then it's going to pick up the default value again.

The specification of a lazy val is pretty simple.
!sc!
    trait Abstract {
        lazy val numerArg = 1 * x
        lazy val denomArg = 1 * x
    }
!/sc!

6.2 Abstract Types                                *scala-abstract-types* {{{2
------------------------------------------------------------------------------

Abstract types allow us to create disparate types when polymorphic types would
have to be used otherwise.

Programming in Scala 2nd Edition has a decent case study at the end of section
20 that explains a decent amount, but it's certainly not comprehensive.
!sc!
    abstract class CurrencyZone {
        // Artifact 1
        type Currency <: AbstractCurrency

        // Artifact 2
        def make(x: Long): Currency

        abstract class AbstractCurrency {
            // Artifact 3
            val amount: Long
            def designation: String

            def + (that: Currency): Currency = make(this.amount + that.amount)
            def * (x: Double): Currency = make((this.amount * x).toLong)
            def - (that: Currency): Currency = make(this.amount - that.amount)
            def / (x: Double) = make((this.amount / x).toLong)
            def / (that: Currency) = this.amount.toDouble / that.amount

            // Artifact 4
            def from(other: CurrencyZone#AbstractCurrency): Currency =
                make(math.round(
                    other.amount.toDouble * Converter.exchangeRate
                        (other.designation)(this.designation)
                    )
                )

            private def decimals(n: Long): Int =
                if (n == 1) 0 else 1 + decimals(n / 10)

            override def toString =
                ((amount.toDouble / CurrencyUnit.amount.toDouble)
                 formatted ("%." + decimals(CurrencyUnit.amount) + "f") +
                    " " + designation)
        }

        // Artifact 5
        val CurrencyUnit: Currency
    }
!/sc!!sc!
    object Converter { // {{{4
        var exchangeRate = Map(
            "USD" -> Map("USD" -> 1.0,
                         "EUR" -> 0.7596,
                         "JPY" -> 1.211,
                         "CHF" -> 1.223),

            "EUR" -> Map("USD" -> 1.316,
                         "EUR" -> 1.0,
                         "JPY" -> 1.594,
                         "CHF" -> 1.623),

            "JPY" -> Map("USD" -> 0.8257,
                         "EUR" -> 0.6272,
                         "JPY" -> 1.0,
                         "CHF" -> 1.018),

            "CHF" -> Map("USD" -> 0.8108,
                         "EUR" -> 0.6160,
                         "JPY" -> 0.982,
                         "CHF" -> 1.0)
        )
    } // }}}4
!/sc!
The initeresting part of the above is its somewhat typical Scala definition; a
design artifact that is somewhat alien to how I think things through.

- Artifact 1: The abstract member type.  Look at where {Currency} is used -
  everywhere.  This is the core type of the definition but it is a type
  parameter defined by the subclass.

- Artifact 2: Scala won't let you create an instance of an abstract class, of
  course, so you need to have a factory method to help you out.  The {make}
  factory method performs this function.

- Artifact 3: A couple of abstract artifacts that the derivations must
  specialize the get the ball rolling.

- Artifact 4: Take a look at the {CurrencyZone#AbstractCurrency}.  This is a
  special syntax in Scala for referencing the inner class.  In Java, this
  would be {CurrencyZone.AbstractCurrency} but that syntax is reserved in
  Scala for {object.type} rather than {class.class} and it speaks to the inner
  type being a |scala-path-dependent-type|, which is a type that is given
  context not by the class in which it is enclosed but by the class /instance/
  within which it is enclosed.

- Artifact 5: Interesting bit here.  Different currencies will have different
  core currency types (e.g. the US may use the Dollar, not the Cent).  and
  this definition of the {CurrencyUnit} will essentially alias that type.

NOTE: There's a /lot/ about this that isn't currently "real" to me.

Once this class definition is in place, we can now create actual currencies
directly.  Let's have a look at creating a US Dollar and a European Euro.
!sc!
    object US extends CurrencyZone {
        abstract class Dollar extends AbstractCurrency {
            def designation = "USD"
        }
        type Currency = Dollar
        def make(cents: Long) = new Dollar {
            val amount = cents
        }
        val Cent = make(1)
        val Dollar = make(100)
        val CurrencyUnit = Dollar
    }

    object Europe extends CurrencyZone {
        abstract class Euro extends AbstractCurrency {
            def designation = "EUR"
        }
        type Currency = Euro
        def make(cents: Long) = new Euro {
            val amount = cents
        }
        val Cent = make(1)
        val Euro = make(100)
        val CurrencyUnit = Euro
    }

    object Japan extends CurrencyZone {
        abstract class Yen extends AbstractCurrency {
            def designation = "JPY"
        }
        type Currency = Yen
        def make(yen: Long) = new Yen {
            val amount = yen
        }
        val Yen = make(1)
        val CurrencyUnit = Yen
    }
!/sc!

6.3 Structural Typing                          *scala-structural-typing* {{{2
------------------------------------------------------------------------------

The best use of structural typing I've seen to date is declaring a generic
type bound on a function - in this case, the loan pattern.
!sc!
    def using[T <: { def close(): Unit }, S](obj: T) (operation: T => S) = {
        val result = operation(obj)
        obj.close()
        result
    }
!/sc!
Structural typing is more than just duck-typing; Scala provides syntactical
support for structural typing as with the above.  Essentially, Scala allows
you to specify an associated superclass not by its type name, but by its
structural definition, including values, variables, types and method
definitions.

Above we see that the {using} function requires a type {T} that has a method
on it called {close} that returns {Unit}.  A {PrintWriter} happens to satisfy
this structure, so definition of the |scala-loan-pattern| we have here would
still work, but so would the following:
!sc!
    using(serverSocket.accept()) { socket =>
        socket.getOutputStream().write("hello, world\n".getBytes)
    }
!/sc!

==============================================================================
7. Functions                                           *scala-functions* {{{1
------------------------------------------------------------------------------

All parameter lists in function definitions are considered to be {val}s.  You
can't reassign a value to a passed in parameter.

7.1 Single Statements                      *scala-single-stmt-functions* {{{2
------------------------------------------------------------------------------

The most basic function definition is a single statement definition.
!sc!
    scala> def func(.. args ..): ReturnType = .. body ..
!/sc!

7.2 Parameterless Methods                 *scala-parameterless-methods* {{{2
------------------------------------------------------------------------------

The general idea here is something like this:
!sc!
    scala> def func(): ReturnType
!/sc!
The above is termed an {empty-paren} method and is used when there are no
parameters and the method accesses mutable state only by reading fields of the
containing object.  This maintains the uniform access principle.


7.3 Procedures                                       *scala-procedures* {{{2
------------------------------------------------------------------------------

Scala functions are destined to return a value, and do so implicitly based on
the value of the final line of the function body, unless explicitly defined to
do otherwise based on the declaration.
!sc!
    scala> def procedure(.. args ..): Unit = {
         |  .. Body defined to return Unit: i.e. nothing ..
         | }
!/sc!
In the case of the above, the {Unit} and the {=} tend to cancel each other
out.  The {=} states that the function results in a value and {Unit} dictates
that the value is non-existant.  Thus, the following "procedure" definition
eliminates the cancellation and makes things simpler:
!sc!
    scala> def procedure(.. args ..) {
         |     .. Body defined to return Unit: i.e. nothing ..
         | }
!/sc!
The {=}, {:} and {Unit} have been eliminated and all replaced with a single
set of curly braces.


7.4 Anonymous Functions                     *scala-anonymous-functions* {{{2
------------------------------------------------------------------------------

Pretty simple...
!sc!
    scala> (.. args ..): ReturnType => .. body ..
!/sc!
It's just not a formal {def} method definition.  You can pass these anywhere,
such as to the *Map.exists()* method:
!sc!
    scala> map.exists((e) => e._1 == "Sentinel Value")
!/sc!
Using the "_" default parameter placeholder, this can be simplified as:
!sc!
    scala> map.exists(_._1 == "Sentinel Value")
!/sc!

7.5 Functions as Parameters                 *scala-functions-as-params* {{{2
------------------------------------------------------------------------------

Functions are just types, nothing really special.  As such, it's no big deal
to toss them in as parameters to functions:
!sc!
    scala> def func(passedIn: (String) => Boolean) = {
         |     passedIn("Hard Coded")
         | }
!/sc!
It's easy to call this with an anonymous function, like this:
!sc!
    scala> func((x: String) => if (x.length > 0) true else false)
    res1: Boolean = true
!/sc!

7.6 Local Functions                             *scala-local-functions* {{{2
------------------------------------------------------------------------------

Local functions are defined within functions.
!sc!
    scala> def outerFunc(files: List[String]) = {
         |     def innerFunc(s) = println("File: " + s)
         |     for (file <- files) innerFunc(file)
         | }
!/sc!

7.7 Assignemtn to val/var                     *scala-functions-as-type* {{{2
------------------------------------------------------------------------------

Since functions are just first class types in Scala, they can be assigned to
values and variables just like anything else.
!sc!
    scala> var varIncrease = (x: Int) => x + 1
    scala> varIncrease(10)
    res1: 11

    scala> varIncrease = (x: Int) => x + 20
    scala> varIncrease(10)
    res1: 31

    scala> val valIncrease = (x: Int) => x + 1
    scala> valIncrease(10)
    res1: 11

    scala> valIncrease = (x: Int) => x + 20
    {console}:1: error: reassignment to val
              valIncrease = (x: Int) => x + 20
!/sc!

7.8 Partial Functions                          *scala-partial-function* {{{2
------------------------------------------------------------------------------

These are known much better to me as bound functions in C++.  These are
functions where only part of the parameters have been applied to.

One of the ways to do this is as the following:
!sc!
    scala> def sum(a, b, c) = a + b + c
    scala> val partial = sum _
    partial: (Int, Int, Int) => Int = {function3}
!/sc!
That defines a {function3} object.  Scala has a set of {traits} called
{FunctionN} where {N} ranges from {0} to {22}.  If you really want to create a
function with more than {22} parameters, you're out of luck, and you probably
should be :)

When you call "partial(1, 2, 3)" defined above, Scala calls:
!sc!
    scala> partial.apply(1, 2, 3)
!/sc!
Of course, you can specify any subset of parameters and create a partially
applied function:
!sc!
    scala> val partial = sum(1, _: Int, 3)
    partial: (Int) => Int = {function1}
!/sc!
So now, "partial" becomes a function with a single paramter and the {apply}
function will now take a single parameter:
!sc!
    scala> partial(2)
    res1: Int = 6
!/sc!

7.9 Closures                                           *scala-closures* {{{2
------------------------------------------------------------------------------

The meat of closures is that they're capable of freezing free state in time so
that it's protected from change and / or it doesn't have to be specified
later - it's specified at the creation source instead of the execution target.

There are a few ways to get state into a closure, but we have to remember what
we're closing on... we're closing on the symbol, not the data it holds.  This
means the following happens:
!sc!
    scala> var more = 10
    more: Int = 10

    scala> val addMore = (x: Int) => x + more
    addMore: (Int) => Int = {function1}

    scala> addMore(10)
    res1: 20

    scala> more = 20
    more: Int = 20

    scala> addMore(10)
    res2: 30
!/sc!
The {addMore} closure is affected by the change to the {more} variable.
However, it's still a closure because of the {more} variable goes out of
scope, the {addMore} function is still valid.  For example:
!sc!
    scala> val addMore = {
         |    var more = 10
         |    (x: Int) => x + more
         | }
    addMore: (Int) => Int = {function1}

    scala> addMore(20)
    res1: 30
!/sc!
Another way to achieve the same is through a factory method:
!sc!
    scala> def factor(more: Int) = (x: Int) => x + more
    factory: (more: Int)(Int) => Int

    scala> val addMore = factory(10)
    addMore: (Int) => Int = {function1}
!/sc!

7.10 Currying                                          *scala-currying* {{{2
------------------------------------------------------------------------------

Currying is a mechanism by which you can supply more than one parameter list
to a function and then apply to those lists separately.  The simplest thing to
do is to take this:
!sc!
    scala> def plainOldSum(x: Int, y: Int) = x + y
    plainOldSum: (x: Int,y: Int)Int

    scala> plainOldSum(1, 2)
    res4: Int = 3
!/sc!
and rewrite to look like this:
!sc!
    scala> def curriedSum(x: Int)(y: Int) = x + y
    curriedSum: (x: Int,y: Int)Int

    scala> curriedSum(1)(2)
    res4: Int = 3
!/sc!
This actually looks like this when it's being executed, because you get two
executions back to back:
!sc!
    scala> def first(x: Int) = (y: Int) => x + y
    first: (x: Int)(Int) => Int

    scala> val second = first(1)
    second: (Int) => Int = {function1}

    scala> second(2)
    res1: Int = 3
!/sc!
You can also get a partial function out of a curried function by giving it a
placeholder parameter:
!sc!
    scala> val onePlus = curriedSum(1)_
    onePlus: (Int) => Int = {function1}
!/sc!
We can now follow on to the |scala-loan-pattern|.


7.11 Loan Pattern                                  *scala-loan-pattern* {{{2
------------------------------------------------------------------------------

The loan pattern implements a "higher-order" function using |scala-currying|.
The pattern itself takes a resource and loans it out to a function that uses
it.  When the function is finished with the resource, the loaner then cleans
it up and releases it.
!sc!
    scala> def fileLoaner(onLoan: File)(loanedTo: PrintWriter => Unit) {
         |     val writer = new PrintWriter(onLoan)
         |     try {
         |         loanedTo(writer)
         |     }
         |     finally {
         |         writer.close()
         |     }
         | }
!/sc!
Which can now be used like this:
!sc!
    scala> fileLoaner(new File("somefile.txt")) {
         |     writer => writer.println(new java.util.Date)
         | }
!/sc!

7.12 "By Name" Parameters                         *scala-byname-params* {{{2
------------------------------------------------------------------------------

The idea of a "by name" parameter is one where the "name" is passed in to the
function, not the value it represents.  This avoids evaluating the paremeter
before the function is called.  A simple example of this is with respect to an
assertion function.
!sc!
    scala> var assertionsEnabled = true
    assertionsEnabled: Boolean = true

    scala> def myAssert(predicate: () => Boolean) =
         |     if (assertionsEnabled && predicate())
         |         throw new AssertionError
    myAssert: (predicate: () => Boolean)Unit
!/sc!
The beauty here is that we don't pay the price of evaluating the predicate
when {assertionsEnabled} is {false}.


7.13 Repeated Parameters                        *scala-repeated-params* {{{2
------------------------------------------------------------------------------

Repeated parameters give us the closest thing we have to variable argument
lists in C++.  It's pretty damn simple; a repeated set of arguments - of the
same type - get sent into the function as an Array[Type].
!sc!
    scala> def echo(args: String*) =
        for (arg <- args) println(arg)
    echo: (args: String*)Unit

    scala> echo("Hi", "there", "guys")
    Hi
    there
    guys
!/sc!
And to see exactly what's happening:
!sc!
    scala> def view(args: String*) = println(args)
    view: (args: String*)Unit

    scala> view("Hi", "there", "guys")
    WrappedArray(Hi, there, guys)
!/sc!
But, that doesn't mean you can pass an Array in to the function and expect it
to do what you want.  The type that you'd be passing in is completely wrong,
and the type system simply won't accept it.  However, you can pull the Array
apart if you have one and need to get it into the function.
!sc!
    scala> val ary = Array("so", "what's", "the", "haps?")
    ary: Array[java.lang.String] = Array(so, what's, the, haps?)

    scala> echo(ary)
    {console}:12: error: type mismatch;
     found   : Array[java.lang.String]
     required: String
           echo(ary)
                ^

    scala> echo(ary: _*)
    so
    what's
    the
    haps?
!/sc!

7.14 Named Arguments                            *scala-named-arguments* {{{2
------------------------------------------------------------------------------

Scala brings the named arguments feature of other languages like Ruby into the
fold.
!sc!
    scala> def speed(distance: Float, time: Float): Float = distance / time
    speed: (distance: Float, time: Float)Float
!/sc!
Now, you can call this in the usual way and get the expected result:
!sc!
    scala> speed(100, 10)
    res1: Float = 10.0
!/sc!
But as expected, the order of those parameters makes a difference.  If you
call it with things in reverse order, the math works out differently.
!sc!
    scala> speed(10, 100)
    res1: Float = 0.1
!/sc!
But, if you really want to do things in reverse order, or you want to do
things for clarity, or whatever other bloody reason you've got, you can simply
name the parameters.
!sc!
    scala> speed(time = 10, distance = 100)
    res1: Float = 10.0
!/sc!

7.15 Default Parameter Values                  *scala-default-arguments* {{{2
------------------------------------------------------------------------------

You gotta have 'em.  This is pretty standard stuff but when you couple it with
|scala-named-arguments| things get a little more sexy.
!sc!
    scala> def printTime(out: java.io.PrintStream = Console.out, divisor: Int = 1) =
        out.println("time = " + System.currentTimeMillis() / divisor)
    printTime: (out: java.io.PrintStream,divisor: Int)Unit
    
    scala> printTime()
    time = 1298321832912
    
    scala> printTime(divisor = 10)
    time = 129832184451
    
    scala> printTime(divisor = 100000)
    time = 12983218
!/sc!

7.16 Tail Recursion                               *scala-tail-recursion* {{{2
------------------------------------------------------------------------------

Scala will optimize tail-recursive calls so long as they're easy to see.  The
problem is that they may be difficult to debug when you seem them in action,
because the call stack won't look the way you think it will.  For example:
!sc!
    scala> def boom(x: Int): Int =
         |     if (x == 0) throw new Exception("boom!")
         |     else boom(x - 1) + 1
!/sc!
That's not tail recursive because the last operation is not a recursive call,
it's an addition call.

Now, if we change that to be tail recursive, we get this:
!sc!
    scala> def boom(x: Int): Int =
         |     if (x == 0) throw new Exception("boom!")
         |     else boom(x - 1)
    boom: (x: Int)Int

    scala> boom(5)
    java.lang.Exception: Boom!
	        at .boom({console}:9)
	        at .{init}({console}:11)
	        at .{clinit}({console})
            ...
!/sc!
That's not the stack we were expecting to see.  If instead we supply
{-g:notailcalls} to the scala interpreter, we ensure that the optimization is
not applied.  If we do that (by calling scala like "scala -g:notailcalls")
then we'll see this:
!sc!
    scala> def boom(x: Int): Int =
         |     if (x == 0) throw new Exception("boom!")
         |     else boom(x - 1)
    boom: (x: Int)Int

    scala> boom(5)
    java.lang.Exception: Boom!
	        at .boom({console}:5)
	        at .boom({console}:5)
	        at .boom({console}:5)
	        at .boom({console}:5)
	        at .boom({console}:5)
	        at .boom({console}:5)
	        at .{init}({console}:7)
	        at .{clinit}({console})
            ...
!/sc!

==============================================================================
8. Predef                                                 *scala-predef* {{{1
------------------------------------------------------------------------------

Scala defines a lot of interesting "flexibility" stuff in the {scala.Predef}
object.  In here you'll find:

- a lot of {implicit} declarations that will magically convert one type to
  another type
- the *format()* function that will format a set of arguments into a given
  text {String}
- the *exit()* and *error()* functions
- various *assert()* functions
- the *classOf()* *classManifest()* and *manifest()* functions
- the *currentThread()* function
- the *print()* *printf()* and *println()* functions
- the *require()* functions

The {Predef} object is included implicitly in all Scala programs by virtue of
the fact that the {scala} namespace is implictly included in all Scala
programs.

The {Predef} object also has a couple of interesting bits in it with respect
to {Set}s and {Map}s.  When you declare a {Map} or a {Set}, without qualifying
a package, you get a {collection.immutable.Map} or a {collection.immutable.Set}
and the reason you get these variants is due to the definitions in {Predef}.
!sc!
    object Predef {
        type Map[A, +B] = collection.immutable.Map[A, B]
        type Set[A] = collection.immutable.Set[A]
        val Map = collection.immutable.Map
        val Set = collection.immutable.Set
        // ...
    }
!/sc!
There is a type {alias} there for each one plus a value that forwards calls
into the right object.

==============================================================================
9. Types                                                    *scala-types* {{{1
------------------------------------------------------------------------------

9.1 Option                                                 *scala-option* {{{2
------------------------------------------------------------------------------

The Option type can have one of two values; either "Some(x)" or "None".  If
it's "None" then there's nothing there and if it's "Some(x)" then the value is
"x".

Scala's Map collection returns an Option from the {get} method:
!sc!
    scala> val capitals = Map("France" -> "Paris", "Japan" -> "Tokyo")
    capitals: scala.collection.immutable.Map[java.lang.String,java.lang.String]
              = Map((France,Paris), (Japan,Tokyo))
    
    scala> capitals get "Japan"
    res11: Option[java.lang.String] = Some(Tokyo)
    
    scala> capitals get "Nowhere"
    res12: Option[java.lang.String] = None
!/sc!
You can take these apart with a pattern match:
!sc!
    scala> capitals.get("Japan") match {  
         |     case Some(city) => println(city)
         |     case None => println("Not found")
         | }
    Tokyo

    scala> capitals.get("Nowhere") match {      
         |     case Some(city) => println(city) 
         |     case None => println("Not found")
         | }                                    
    Not found
!/sc!
Option is used when you want to say that something is optional.  In Java, the
way to do this (and the way you /must/ do this) is to use {null}.  You can't
opt-out of this either, so you can actually get a {null} at any time on any
variable.

Option is a much better alternative for a few reasons.

- It's clear.  When you specify Option[String] in an API, you're being
  entirely clear that there may not be a {String} returned at all.

- Eliminates the {null}.  Value types can't be {null} so if you stick value
  types in a collection, then you can't find {null}s in there.

- There are deterministic mechanisms for dealing with them via pattern
  matching or other mechanisms supported by the language.  If you try to use
  an Option[String] as a String, then the compiler will yell at you.


9.1.1 Option as Monad                                *scala-option-monad* {{{3
------------------------------------------------------------------------------

The {Option} class is a true monad, which gives us the following nice
consequence (from the scaladoc):
!sc!
    val name: Option[String] = request.getParameter("name")
    val upper = name map { _.trim } filter {
        _.length != 0 } map { _.toUpperCase }
    println(upper.getOrElse(""))
!/sc!
And that's equivalent to:
!sc!
    val upper = for {
        name <- request.getParameter("name")
        trimmed <- Some(name.trim)
        upper <- Some(trimmed.toUpperCase) if trimmed.length != 0
    } yield upper
    println(upper.getOrElse(""))
!/sc!
The beauty here is that the {None} derivation defines deterministic behaviour
for the methods used above.  As such, when things fail, the failure is
propagated throughout such that we get {None} at the end.


9.1.2 Option Cheat Sheet                       *scala-option-cheat-sheet* {{{3
------------------------------------------------------------------------------

flatMap                                                 *scala-option-flatMap*
!sc!
      option match {
        case None => None
        case Some(x) => foo(x)
      }
!/sc!
  Equivalent to:
!sc!
      option.flatMap(foo(_))
!/sc!
map                                                         *scala-option-map*
!sc!
      option match {
        case None => None
        case Some(x) => Some(foo(x))
      }
!/sc!
  Equivalent to:
!sc!
      option.map(foo(_))
!/sc!
foreach                                                 *scala-option-foreach*
!sc!
      option match {
        case None => {}
        case Some(x) => foo(x)
      }
!/sc!
  Equivalent to:
!sc!
      option.foreach(foo(_))
!/sc!
isDefined                                             *scala-option-isDefined*
!sc!
      option match {
        case None => false
        case Some(_) => true
      }
!/sc!
  Equivalent to:
!sc!
      option.isDefined
!/sc!
isEmpty                                                 *scala-option-isEmpty*
!sc!
      option match {
        case None => true
        case Some(_) => false
      }
!/sc!
  Equivalent to:
!sc!
      option.isEmpty
!/sc!
forall                                                   *scala-option-forall*
!sc!
      option match {
        case None => true
        case Some(x) => foo(x)
      }
!/sc!
  Equivalent to:
!sc!
      option.forall(foo(_))
!/sc!
exists                                                   *scala-option-exists*
!sc!
      option match {
        case None => false
        case Some(x) => foo(x)
      }
!/sc!
  Equivalent to:
!sc!
      option.exists(foo(_))
!/sc!
orElse                                                   *scala-option-orElse*
!sc!
      option match {
        case None => foo
        case Some(x) => Some(x)
      }
!/sc!
  Equivalent to:
!sc!
      option.orElse(foo)
!/sc!
orNull                                                   *scala-option-orNull*
!sc!
      option match {
        case None => null
        case Some(x) => Some(x)
      }
!/sc!
  Equivalent to:
!sc!
      option.orNull
!/sc!
getOrElse                                             *scala-option-getOrElse*
!sc!
      option match {
        case None => foo
        case Some(x) => x
      }
!/sc!
  Equivalent to:
!sc!
      option.getOrElse(foo)
!/sc!
toList                                                   *scala-option-toList*
!sc!
      option match {
        case None => Nil
        case Some(x) => x :: Nil
      }
!/sc!
  Equivalent to:
!sc!
      option.toList
!/sc!

9.2 Array                                                   *scala-array* {{{2
------------------------------------------------------------------------------

The Scala Array is really just a representation of the Java Array, fixed up to
work properly in the Scala environmnet.  The Java version is quirky in that
{length} (for example) is a field and not a method.

In order to be of any real use in Scala, the Array class needs to be
implicitly converted into the {WrappedArray} class, which is done for us quite
nicely, and transparently by the |scala-predef| object's implicit definitions.
The {WrappedArray} class gives us a ton more methods from mixins across the
Scala library.
!sc!
    scala> val ary = Array[String]("This", "is", "an", "Array",
         |                         "of", "Strings")
    ary: Array[String] = Array(This, is, an, Array, of, Strings)
    
    scala> val ary1 = Array("This", "is", "an", "Array",
         |                  "of", "Strings")        
    ary1: Array[java.lang.String] = Array(This, is, an, Array, of, Strings)
!/sc!
Note that you can use an explicit Array element type, as you can with any
generic class / trait but Scala will also deduce as required.


9.3 Range                                                  *scala-range* {{{2
------------------------------------------------------------------------------

Range is a very simple type that exist in many other languages but is still
quite a cool deal.  What's even more fun is how they generally get constructed
in Scala programs.  The {RichInt} (|scala-richint|) class has some methods on
it that help us out:
!sc!
    // Inclusive and ByOne are members of scala.collection.immutable.Range
    def to(end: Int, step: Int): Inclusive
    def to(end: Int): Inclusive with ByOne

    // ByOne is a member of scala.collection.immutable.Range
    def until(end: Int, step: Int): Range
    def until(end: Int): Range with ByOne
!/sc!
Now, because {RichInt} (|scala-richint|) is implicitly converted to from {Int}
via the implicit converters present in {Predef} (|scala-predef|) we get a nice
and easy syntax for creating Ranges:
!sc!
    scala> for (i <- 1 to 5) println(i)
    1
    2
    3
    4
    5

    scala> for (i <- 1 until 5) println(i)
    1
    2
    3
    4
!/sc!

==============================================================================
9.4 List                                                    *scala-list* {{{2
------------------------------------------------------------------------------

Lists are probably the most commonly used data structure in Scala programs.
Lists are unlike Arrays in that a couple of ways:

- Lists are immutable

- Lists have a recursive structure (i.e. a linked list) whereas arrays are
  flat

Lists are covariant (|scala-covariant|), meaning that the following is
possible:
!sc!
    scala> val l = List("One", "Two", "Three")
    l: List[java.lang.String] = List(One, Two, Three)
    
    scala> l
    res0: List[java.lang.String] = List(One, Two, Three)
    
    scala> val ol: List[Object] = l
    ol: List[java.lang.Object] = List(One, Two, Three)
    
    scala> ol
    res1: List[java.lang.Object] = List(One, Two, Three)
!/sc!
Note that a "List()" is of type "List[Nothing]", which is perfectly OK because
of covariance.  {Nothing} is the bottom type of everything else, so it will
defeinitely inherit the type you're intending to use.
!sc!
    scala> val l: List[String] = List()
    l: List[String] = List()
    
    scala> val t = List[String]()
    t: List[String] = List()
    
    scala> val u = List.empty[String]
    u: List[String] = List()
!/sc!
All operations on lists can be expressed in terms of the following three:

- head:    returns the first element of a list
- tail:    returns a list consisting of all elements except the first
- isEmpty: returns {true} if the list is empty

The best idea is to organize your data in {List} such that the work being done
on it is centred around the front of the list.  If you're working at the end
of the list, it's going to get expensive, so avoid using |scala-list-init| and
|scala-list-last| frequently.


9.4.1 And Pattern Matching                      *scala-list-and-patterns* {{{3
------------------------------------------------------------------------------

Lists can be taken apart via pattern matching in a couple of different ways:
!sc!
    scala> val list = List(1, 2, 3)
    list: List[Int] = List(1, 2, 3)
    
    scala> val List(a, b, c) = list
    a: Int = 1
    b: Int = 2
    c: Int = 3
!/sc!
That only works if you know exactly how many elements the list actually has,
which isn't necessarily easy to know all the time.  The more flexible way to
do this is with the {cons} operator.
!sc!
    scala> val list = List(1, 2, 3, 4, 5)
    list: List[Int] = List(1, 2, 3, 4, 5)
    
    scala> val a :: b :: rest = list
    a: Int = 1
    b: Int = 2
    rest: List[Int] = List(3, 4, 5)
!/sc!
In patterns, we work with |scala-extractors| and constructors, not method
calls.  So when we see something like "b :: rest" we have to understand that
this gets interpreted as "::(b, rest)" and this is actually a pattern
constructor.  This constructor actually does exist and it's called {scala.::},
so {::} exists twice in Scala, once as a name of a class in package {scala}
and again as a method in class {List}.


9.4.2 Various Operations                        *scala-list-operations* {{{3
------------------------------------------------------------------------------

::                                                      *scala-::* *scala-cons*
    The {List} {cons} operator prepends an element to the {List}.  This is a
    constant time operation and is thus very cheap.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)
        
        scala> val newlist = 0 :: list
        newlist: List[Int] = List(0, 1, 2, 3)
!/sc!
    Note that the {::} operator associates to the right, as do all operators
    that end with {:}.  The method is actually executed on the {list} in the
    above code snippet, not on the {Int}.

    You can construct {List}s using the {::} operator, coupled with the {Nil}
    object, which is of type {List}.
!sc!
        scala> val list = 1 :: 2 :: 3 :: 4 :: 5 :: Nil
        list: List[Int] = List(1, 2, 3, 4, 5)
!/sc!
    You need to specify {Nil} at the "end" of this list because the {::}
    operator is an operator on the {List} type, not in the {Int} type and,
    since the {::} is right-associative, it will associate with whatever is
    ultimately on the right, and that's the {Nil} {List} object.

:::                                            *scala-:::* *scala-list-concat*
    The {List} concatenation operator sticks two lists together.
!sc!
        scala> val list = List(1, 2, 3) ::: List(4, 5)
        list: List[Int] = List(1, 2, 3, 4, 5)
!/sc!
    Note as with {::}, the {:::} operator associates to the right.

head                                                       *scala-list-head*
    Returns the head of the list.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)

        scala> list.head
        res0: Int = 1
!/sc!
    Throws {NoSuchElementException} if called on an empty list

tail                                                       *scala-list-tail*
    Returns the tail of the list.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)

        scala> list.tail
        res0: List[Int] = List(2, 3)
!/sc!
    Throws {UnsupportedOperationException} if called on an empty {List}.  If
    the {List} only has a single element, then an empty {List} is returned.

init                                                       *scala-list-init*
    Returns a new {List} minus the head; this is the inverse of tail.  This is
    inefficient.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)

        scala> list.init
        res0: List[Int] = List(1, 2)
!/sc!
    Throws {UnsupportedOperationException} if called on an empty {List}.
    Returns an empty {List} if the {List} only has one element.

last                                                       *scala-list-last*
    Returns the last element in the list as a value; this is the inverse of
    head.  This is inefficient.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)

        scala> list.last
        res0: Int = 3
!/sc!
    Throws {UnsupportedOperationException} if called on an empty {List}.

reverse                                                 *scala-list-reverse*
    Reverse will return a new {List} with the elements in reverse order.  This
    is linear in complexity.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)

        scala> list.reverse
        res23: List[Int] = List(3, 2, 1)
!/sc!
    Reverse works with some of the previous notions to give algorithmic
    equality to them.

        xs.reverse.reverse equals xs
        xs.reverse.init equals xs.tail.reverse
        xs.reverse.tail equals xs.init.reverse
        xs.reverse.head equals xs.last
        xs.reverse.last equals xs.head

drop                                                       *scala-list-drop*
    Returns a new {List} minus the first {n} elements.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        
        scala> list.drop(4)
        res0: List[Int] = List(5, 6, 7, 8, 9)
!/sc!
    Returns an empty list if there are less than {n+1} elements in the {List}
    and an empty list if the {List} is empty.

take                                                       *scala-list-take*
    Returns a new {List} containing only the first {n} elements.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        
        scala> list.take(4)
        res0: List[Int] = List(1, 2, 3, 4)
!/sc!
    Returns an empty list if the {List} was empty and a list with length less
    than {n} if the receiving list has length less than {n}.

splitAt                                                 *scala-list-splitAt*
    Returns a {Tuple2} (or colloquially known as a {pair}) that's split at
    index {n}, where the first list has elements from 0 to {n-1} and the
    second list has element from {n} to the end.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8)
        
        scala> list.splitAt(4)
        res8: (List[Int], List[Int]) = (List(1, 2, 3, 4),List(5, 6, 7, 8))
!/sc!
    If the index is outside the range of the receiver, then the second list is
    always empty, and if the reciever is empty, both resulting lists are
    empty.

indices                                                  *scala-list-indices*
    Returns a |scala-range| containing the zero-based index list of the
    elements in the {List}.
!sc!
        scala> val words = List("some", "words", "are", "in", "this", "list")
        words: List[java.lang.String] = List(some, words, are, in, this, list)
        
        scala> words.indices 
        res15: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4, 5)
!/sc!
flatten                                                  *scala-list-flatten*
    Takes a recursively defined {List} and flattens it out one level deep and
    returns a new {List}.
!sc!
        scala> List(List(1, 2), List(3), List(), List(4, 5)).flatten
        res16: List[Int] = List(1, 2, 3, 4, 5)

        scala> List(List(1, 2), List(List(3)), List(), List(4, 5)).flatten
        res17: List[Any] = List(1, 2, List(3), 4, 5)
!/sc!
    Note the return value of {List[Any]} above.

zip                                                          *scala-list-zip*
    Takes two {List}s and zips them together into a single {List} of pairs
    whos length is the minimum of the length of the two originating lists.
!sc!
        scala> List(1, 2, 3) zip List("a", "b", "c", "d")
        res18: List[(Int, java.lang.String)] = List((1,a), (2,b), (3,c))
!/sc!
unzip                                                      *scala-list-unzip*
    Takes a {List} of pairs and splits it up into a pair of {List}s.
!sc!
        scala> val zipped = List(1, 2, 3) zip List("a", "b", "c", "d")
        zipped: List[(Int, java.lang.String)] = List((1,a), (2,b), (3,c))
        
        scala> zipped.unzip
        res20: (List[Int], List[java.lang.String]) =
                    (List(1, 2, 3),List(a, b, c))
!/sc!
mkString                                                *scala-list-mkString*
    Concatenates all of the elements of the {List} together into a string,
    using a delimeter and a prefix / postfix pair.
!sc!
        scala> val abcde = List("a", "b", "c", "d", "e")
        abcde: List[java.lang.String] = List(a, b, c, d, e)
        
        scala> abcde.mkString("ABCDE[", ", ", "]")
        res22: String = ABCDE[a, b, c, d, e]
!/sc!
addString                                              *scala-list-addString*
    Due to the immutability factor, mkString can be expensive.  In these cases
    we have the {addString} method that can use a |scala-stringbuilder| object
    to create the string without the cost of the immutable data structure.
!sc!
        scala> val buf = new StringBuilder
        buf: StringBuilder = StringBuilder()
        
        scala> abcde.addString(buf, "ABCDE[", ", ", "]")
        res24: StringBuilder = StringBuilder(
            A, B, C, D, E, [, a, ,,  , b, ,,  , c, ,,  , d, ,,  , e, ])
        
        scala> buf.toString
        res25: java.lang.String = ABCDE[a, b, c, d, e]
!/sc!
iterator                                                *scala-list-iterator*
    You can grab yourself an iterator pretty easily.
!sc!
        scala> val iter = list.iterator
        iter: Iterator[Int] = non-empty iterator
        
        scala> iter.hasNext
        res27: Boolean = true
        
        scala> iter.next
        res28: Int = 1
        
        scala> iter.next
        res29: Int = 2
        
        scala> iter.next
        res30: Int = 3
!/sc!
map                                                          *scala-list-map*
    Map executes a function over element in the list and returns a new list
    containing all the new values.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.map(_ * 2)
        res32: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18)
!/sc!
flatMap                                                  *scala-list-flatmap*
    Flatmap is the same as |scala-list-map| except for the fact that it will
    also flatten the {List} at the same time.  I'm a little foggy on this one
    though... based on that description, I would have expected that the
    following would work:
!sc!
        scala> val deepList = List(1, 2, List(3, 4, 5), 6, 7, List(8, 9))
        deepList: List[Any] = List(1, 2, List(3, 4, 5), 6, 7, List(8, 9))
        
        scala> deepList.flatMap(_.asInstanceOf[Int] * 2)
        {console}:7: error: type mismatch;
         found   : Int
         required: Traversable[?]
               deepList.flatMap(_.asInstanceOf[Int] * 2)
                                                    ^
!/sc!
    Instead, what we need is literally a {List} of {List}s and nothing more,
    and then it would seem that we can only do operations on the elements,
    which are themselves {List}s.
!sc!
        scala> val listOfLists = List(List(1, 2, 3),
             |                        List(4, 5, 6),
             |                        List(7, 8, 9))
        listOfLists: List[List[Int]] = List(List(1, 2, 3),
                                            List(4, 5, 6),
                                            List(7, 8, 9))
        
        scala> listOfLists.flatMap(_.toList)
        res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
!/sc!
foreach                                                  *scala-list-foreach*
    Foreach runs the passed in function over each element of the list but
    returns {Unit}.  Everything that's done to the {List} is a side effect.
    The simplest example of this is printing out the elements.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.foreach(println)                        
        1
        2
        3
        4
        5
        6
        7
        8
        9
!/sc!
filter                                                    *scala-list-filter*
    Returns a new {List} composed of elements of the receiver where the passed
    in predicate evaluates to {true}.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.filter(_ % 2 == 0)
        res0: List[Int] = List(2, 4, 6, 8)
!/sc!

partition                                              *scala-list-partition*
    Works like |scala-list-filter| except it returns both the {List} that
    would have been returned by {filter} as well as a {List} of elements that
    would not have been returned by {filter}.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.partition(_ % 2 == 0)
        res0: (List[Int], List[Int]) = (List(2, 4, 6, 8),List(1, 3, 5, 7, 9))
!/sc!
find                                                        *scala-list-find*
    Returns an Option (|scala-option|) containing the first result of trying
    to find an element in the {List} that matches the predicate.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.find(_ % 2 == 0)
        res0: Option[Int] = Some(2)
!/sc!
takeWhile                                              *scala-list-takeWhile*
    Continues to |scala-list-take| while the predicate is true.  Take takes up
    to {n} and takeWhile uses a predicate to decide what to take.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.takeWhile(_ < 5)      
        res0: List[Int] = List(1, 2, 3, 4)
!/sc!
dropWhile                                              *scala-list-dropWhile*
    Continues to |scala-list-drop| while the predicate is true.  Drop drops up
    to {n} and dropWhile uses a predicate to decide what to drop.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.dropWhile(_ < 5)      
        res0: List[Int] = List(5, 6, 7, 8, 9)
!/sc!
forall                                                    *scala-list-forall*
    Executes the predicate across all elements in the {List} and returns
    {true} if the predicate is satisfied for all elements.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.forall(_ > 0)      
        res0: Boolean = true

        scala> list.forall(_ < 7)      
        res1: Boolean = false
!/sc!
exists                                                    *scala-list-exists*
    Returns {true} if there is a single element that satisfies the predicate.
!sc!
        scala> val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
        list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)

        scala> list.exists(_ == 5)      
        res0: Boolean = true

        scala> list.forall(_ == 22)      
        res1: Boolean = false
!/sc!
/:                                             *scala-list-foldleft* *scala-/:*
    FoldLeft.  This is unlike some of the other higher order functions in that
    this one applies against two arguments.  The simplest way to explain it is
    through an example, where we'll play with some numbers.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)
        
        scala> (0 /: list)(_ + _)
        res0: Int = 6
        
        scala> list.foldLeft(0)(_ + _)
        res1: Int = 6
!/sc!
    This creates an expression that leans to the left:

                                +
                               / \
                              +   3
                             / \
                            +   2
                           / \
                          0   1

    Another example:
!sc!
        scala> val list = List(2, 2, 3)
        list: List[Int] = List(2, 2, 3)
        
        scala> (1 /: list)(_ * _)
        res0: Int = 12
        
        scala> list.foldLeft(1)(_ * _)
        res1: Int = 12
!/sc!
    Which creates an expression with the same structure, just different
    values.

                                *
                               / \
                              *   3
                             / \
                            *   2
                           / \
                          1   2

:\                                            *scala-list-foldright* *scala-:\*
    FoldRight.  This is like |scala-list-foldleft| except that it folds to the
    right.  The argument structure is different due to the fact that things
    fold to the right.
!sc!
        scala> val list = List(1, 2, 3)
        list: List[Int] = List(1, 2, 3)
        
        scala> (list :\ 0)(_ + _)
        res0: Int = 6
        
        scala> list.foldRight(0)(_ + _)
        res1: Int = 6
!/sc!
    This creates an expression that leans to the left:

                           +
                          / \
                         3   +
                            / \
                           2   +
                              / \
                             1   0

    Another example:
!sc!
        scala> val list = List(2, 2, 3)
        list: List[Int] = List(2, 2, 3)
        
        scala> (list :\ 1)(_ * _)
        res0: Int = 12
        
        scala> list.foldLeft(1)(_ * _)
        res1: Int = 12
!/sc!
    Which creates an expression with the same structure, just different
    values.

                           *
                          / \
                         3   *
                            / \
                           2   *
                              / \
                             2   1


9.4.3 Construction Options                    *scala-list-construction* {{{3
------------------------------------------------------------------------------

List.range                                                 *scala-list-range*
    The range method on the {List} object will create a {List} object that's
    like a range object, but isn't a range object.
!sc!
        scala> List.range(1, 5)
        res0: List[Int] = List(1, 2, 3, 4)

        scala> List.range(1, 9, 2)
        res1: List[Int] = List(1, 3, 5, 7)

        scala> List.range(9, 1, -3)
        res2: List[Int] = List(9, 6, 3)
!/sc!
List.fill                                                   *scala-list-fill*
    The fill method creates a new list of a particular size with each element
    set to a given value.
!sc!
        scala> List.fill(5)('a')
        res0: List[Char] = List(a, a, a, a, a)

        scala> List.fill(3)("hello")
        res1: List[java.lang.String] = List(hello, hello, hello)

        scala> List.fill(2, 3)('b')
        res2: List[List[Char]] = List(List(b, b, b), List(b, b, b))
!/sc!
List.tabulate                                           *scala-list-tabulate*
    Constructs an object much like |scala-list-fill| but uses a function to
    fill in the values instead of a hard-coded value.
!sc!
        scala> val squares = List.tabulate(5)(n => n * n)
        squares: List[Int] = List(0, 1, 4, 9, 16)

        scala> val multiplication = List.tabulate(5,5)(_ * _)
        multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
            List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
            List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))
!/sc!
List.concat                                               *scala-List-concat*
    The concat method concatenates a number of element lists. The lists to be
    concatenated are supplied as direct arguments to concat:
!sc!
        scala> List.concat(List('a', 'b'), List('c'))
        res60: List[Char] = List(a, b, c)
        
        scala> List.concat(List(), List('b'), List('c'))
        res61: List[Char] = List(b, c)
        
        scala> List.concat()
        res62: List[Nothing] = List()
!/sc!

9.5 ArrayBuffer                                     *scala-array-buffer* {{{2
------------------------------------------------------------------------------

The ArrayBuffer is an Array that allows you to add and remove elements from
the beginning and the end.


9.6 String                                                *scala-string* {{{2
------------------------------------------------------------------------------

String comes in a few different flavours but you never have to really know
about the different ones because they're implicitly converted to.

The root String that's important is the {java.lang.String} and the magic is
done by the |scala-predef| object, specifically the {augmentString} and
{unaugmentString} implicit methods.  It converts the {java.lang.String} to and
from the {StringOps} class, and it's the {StringOps} class that carries all of
the interesting bits and pieces in it.

There is also a {WrappedString} but it's not much different than the
{StringOps} class.  The only real difference is that where the StringOps class
would return a {String} object (that may later need conversion back to
{StringOps}) the {WrappedString} class returns {WrappedString} objects.


9.6.6 StringOps                                       *scala-stringops* {{{3
------------------------------------------------------------------------------

* (n: Int) : String                                        *scala-string-star*
    Return the current string concatenated n times.
!sc!
        scala> "| a string |" * 3
        res0: String = | a string || a string || a string |
!/sc!
++ (that: TraversableOnce[Char]) : StringOps[A]              *scala-string-++*
    Concatenates this string with the elements of a traversable collection.
!sc!
        scala> "str: " ++ List(1, 2, 3, 4)     
        res0: scala.collection.immutable.IndexedSeq[AnyVal] =
          Vector(s, t, r, :,  , 1, 2, 3, 4)
!/sc!
+: (elem: Char) : StringOps[A]                                *scala-string-+*
    Prepends an element to this string
!sc!
        scala> 'c' + "harlie"
        res0: java.lang.String = charlie
!/sc!

/: [B] (z: B)(op: (B, Char)  B) : B                         *scala-string-/:*
    Applies a binary operator to a start value and all elements of this
    string, going left to right.
!sc!
        scala> ("h" /: "ithere")(_ + _) 
        res0: java.lang.String = hithere
!/sc!

:+ (elem: Char) : StringOps[A]                               *scala-string-:+*
    Appends an element to this string
!sc!
        scala> "hithere " + 'g' + 'u' + 'y' + 's'
        res0: java.lang.String = hithere guys
!/sc!

:\ [B] (z: B)(op: (Char, B)  B) : B                         *scala-string-:\*
    Applies a binary operator to all elements of this string and a start
    value, going right to left.
!sc!
        scala> ("h" :\ "ithere")(_ + _)
        res0: java.lang.String = hithere
!/sc!

addString (b: StringBuilder) : StringBuilder          *scala-string-addString*
    Appends all elements of this string to a string builder.
!sc!
        scala> val b = new StringBuilder
        b: StringBuilder = StringBuilder()
        
        scala> "hithere".addString(b)
        res0: StringBuilder = StringBuilder(h, i, t, h, e, r, e)
        
        scala> " folks".addString(b)
        res1: StringBuilder = StringBuilder(h, i, t, h, e, r, e,  ,
                                            f, o, l, k, s)
!/sc!
capitalize : String                                *scala-string-capitalize*
    Returns this string with first character converted to upper case
!sc!
        scala> "booger".capitalize
        res0: String = Booger
!/sc!
contains (elem: Any) : Boolean                       *scala-string-contains*
    Tests whether this string contains a given value as an element
!sc!
        scala> "booger".contains("oog") 
        res37: Boolean = true
!/sc!
r () : Regex                                            *scala-string-regex*
    Returns a regular expression object using the data contained in the
    {String}.  For more info, see |scala-regular-expressions|.
!sc!
        scala> """\d+\.\d+""".r
        res0: scala.util.matching.Regex = \d+\.\d+
!/sc!

9.7 Sets and Maps                                  *scala-sets-and-maps* {{{2
------------------------------------------------------------------------------

The immutable version of Set and Map (which are actually forward references
for {HashSet} and {HashMap}) have some "small collection" optimizations.
There are different classes to handle different sizes of collections:

 Type | Number of elements | Implementation
 -----+--------------------+-------------------------------------
 Map  | 0                  | scala.collection.immutable.EmptyMap
 Map  | 1                  | scala.collection.immutable.Map1
 Map  | 2                  | scala.collection.immutable.Map2
 Map  | 3                  | scala.collection.immutable.Map3
 Map  | 4                  | scala.collection.immutable.Map4
 Map  | 5 or more          | scala.collection.immutable.HashMap
 -----+--------------------+-------------------------------------
 Set  | 0                  | scala.collection.immutable.EmptySet
 Set  | 1                  | scala.collection.immutable.Set1
 Set  | 2                  | scala.collection.immutable.Set2
 Set  | 3                  | scala.collection.immutable.Set3
 Set  | 4                  | scala.collection.immutable.Set4
 Set  | 5 or more          | scala.collection.immutable.HashSet


9.8 Regular Expressions                      *scala-regular-expressions* {{{2
------------------------------------------------------------------------------

Regular expressions come in package {scala.util.matching.Regex}.  You can
construct them using two specific methods...
!sc!
    scala> import scala.util.matching.Regex

    scala> val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
    Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?

        (or equivalently)

    scala> val Decimal = new Regex("""(-)?(\d+)(\.\d*)?""")
    Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
!/sc!
... and ...
!sc!
    scala> import scala.util.matching.Regex

    scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
    Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
!/sc!

9.8.1 Methods on Regex                             *scala-regex-methods* {{{3
------------------------------------------------------------------------------

                                                        *scala-regex-findAllIn*
findAllIn (source: CharSequence) : MatchIterator
    Return all matches of this regexp in given character sequence as an
    iterator
!sc!
        scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
        Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
        
        scala> val input = "for -1.0 to 99 by 3"
        input: java.lang.String = for -1.0 to 99 by 3
        
        scala> for (s <- Decimal findAllIn input) println(s)
        -1.0
        99
        3
!/sc!
                                                      *scala-regex-findFirstIn*
findFirstIn (source: CharSequence) : Option[String]
    Return optionally first matching string of this regexp in given character
    sequence, None if it does not exist.
!sc!
        scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
        Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
        
        scala> val input = "for -1.0 to 99 by 3"
        input: java.lang.String = for -1.0 to 99 by 3
        
        scala> Decimal findFirstIn input
        res1: Option[String] = Some(-1.0)
!/sc!

                                                 *scala-regex-findFirstMatchIn*
findFirstMatchIn (source: CharSequence) : Option[Match]
    Return optionally first match of this regexp in given character sequence,
    None if it does not exist.

                                                *scala-regex-findPrefixMatchOf*
findPrefixMatchOf (source: CharSequence) : Option[Match]
    Return optionally match of this regexp at the beginning of the given
    character sequence, or None if regexp matches no prefix of the character
    sequence.

                                                     *scala-regex-findPrefixOf*
findPrefixOf (source: CharSequence) : Option[String]
    Return optionally match of this regexp at the beginning of the given
    character sequence, or None if regexp matches no prefix of the character
    sequence.

                                                     *scala-regex-replaceAllIn*
replaceAllIn (target: CharSequence, replacer: (Match)  String) : String
    Replaces all matches using a replacer function.

    {target}
        The string to match.
    
    {replacer}
        The function which maps a match to another string.
    
    {returns}
        The target string after replacements. 

replaceAllIn (target: CharSequence, replacement: String) : String
    Replaces all matches by a string.

    {target}
        The string to match
    
    {replacement}
        The string that will replace each match
    
    {returns}
        The resulting string 
    
                                                 *scala-regex-replaceFirstIn*
replaceFirstIn (target: CharSequence, replacement: String) : String
    Replaces the first match by a string.

    {target}
        The string to match
    
    {replacement}
        The string that will replace the match
    
    {returns}
        The resulting string 

                                                 *scala-regex-replaceSomeIn*
replaceSomeIn (target: CharSequence, replacer: (Match) => Option[String]) : String

                                                         *scala-regex-split*
split (toSplit: CharSequence) : Array[String]
    Splits the provided character sequence around matches of this regexp.


9.8.2 Pattern Matching                    *scala-regex-pattern-matching* {{{3
------------------------------------------------------------------------------

Every {Regex} object is automatically an object that can easily pattern match.
Let's look at:
!sc!
    scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
    Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?

    scala> val Decimal(sign, integerpart, decimalpart) = "-1.23"
    sign: String = -
    integerpart: String = 1
    decimalpart: String = .23

    scala> val Decimal(sign, integerpart, decimalpart) = "1.0"  
    sign: String = null
    integerpart: String = 1
    decimalpart: String = .0
!/sc!
And you can combine this with a {for} expression.
!sc!
    scala> val input = "for -1.0 to 99 by 3"
    input: java.lang.String = for -1.0 to 99 by 3

    scala> for (Decimal(s, i, d) <- Decimal findAllIn input) {
         |     println("sign: " + s + ", integer: " + i + ", decimal: " + d)
         | }
    sign: -, integer: 1, decimal: .0
    sign: null, integer: 99, decimal: null
    sign: null, integer: 3, decimal: null
!/sc!
The "date" example is cool too:
!sc!
    scala> val regex = """(\d+)/(\d+)/(\d+)""".r
    scala> val regex(year, month, day) = "2010/1/13"
    year: String = 2010
    month: String = 1
    day: String = 13
!/sc!

==============================================================================
10. Packages and Access Modifiers                        *scala-packages* {{{1
------------------------------------------------------------------------------

Scala's got packaging and access modifiers that seems to be a cross between
C++ and Java and includes some enhancements not found in either.  The first
thing to know is that Java's magical side-effects that are found in some of
the access modifiers (e.g. "protected" gives package-level access to the data)
are not found in Scala.


10.1 Access Rules                                          *scala-access* {{{2
------------------------------------------------------------------------------

- All attributes are public unless declared otherwise.  There is no "public"
  keyword in Scala
- {private} is just like in C++
- {protected} is just like in C++

Both {private} and {protected} can have {modifiers} added on to them.  A
{modifier} takes the form of [symbol] where 'symbol' is a user-defined entity
in Scala.
!sc!
    package bobsrockets

    package navigation {

      // Visible within 'bobsrockets' package
      private[bobsrockets] class Navigator {

        // Visible within 'navigation' package
        protected[navigation] def useStarChart() {}
        class LegOfJourney {

          // Visible to the Navigator class
          private[Navigator] val distance = 100
        }
        // Only visible within instances.  This one's interesting - it means
        // that 'speed' is not visible between instances.  So you can't access
        // a particular instance's 'speed' variable outside of that instance
        private[this] var speed = 200
      }
    }

    package launch {
      import navigation._
      object Vehicle {

        // Visible to anything in the launch package
        // Note that we can see 'Navigator' below because we're still inside
        // the 'bobsrockets' package
        private[launch] val guide = new Navigator
      }
    }
!/sc!

10.2 Packaging                                          *scala-packaging* {{{2
------------------------------------------------------------------------------

Packaging is pretty much the same as Java except for the imports and a cool
|scala-package-object|.
!sc!
    // This package is global to the entire file
    package main.pkg
    
    package subpkg {
        // Everything declared in here is within the
        // main.pkg.subpkg package
        package subsubpkg {
            // And, of course, we can go further down
            // and add more and more packages within
            // packages
        }
    }

    package anotherSubPkg {
        // And you can just keep doing this stuff
    }
!/sc!
                                                             *scala-imports*

Scala provides some pretty decent importing mechanisms as well.  You can
selectively import, import all, hide and rename.
!sc!
    // Imports the Actor class and object
    import akka.actor.Actor

    // Imports all of the members of the Actor directly into this namespace
    import akka.actor.Actor._

    // Imports the 'actorOf' factory method but renames it
    import akka.actor.Actor.{actorOf => actorFactory}

    // Imports only the Actor and Supervisor classes
    import akka.actor.{Actor, Supervisor}

    // Imports everything from the actor namespace /except/ Supervisor
    // This effectively /hides/ Supervisor
    import akka.actor.{Supervisor => _, _}
!/sc!
You can also import anywhere you feel like.  If you want to import within a
function definition, go for it.

                                                      *scala-package-object*

You can also create an object that is essentially right at the package level.
This allows us to create something akin to "free functions" that exist in C++.
The object itself has to be named the same as the package in which it's
declared and should be in a file called {packagename/package.scala}, where
"packagename" is the name of the package.

!sc!"mypackage/package.scala"

    package mypackage
    import scala.collection.immutable.Map

    package object mypackage {
        def pkgLeveFunction(someMap: Map[String, String]) = {
            println(someMap)
        }
    }
!/sc!

==============================================================================
11. Type Parameterization                               *scala-generics* {{{1
------------------------------------------------------------------------------

Type parameterization is the equivalent of the usage of {generics} in Java or
C# but is weaker than {templates} in C++.


11.1 Type Variance                                      *scala-variance* {{{2
------------------------------------------------------------------------------

Scala defines mechanisms to handle three variance types.

                                                          *scala-nonvariance*
- Nonvariance: Kinda like C++.  If S is a subtype of T a vector<S> is not a
  subtype of vector<T>.
!sc!
    scala> class Variance[T](init: T) {                                    
         |     val t: T = init
         |     override def toString = "Variance[" + t + "]"
         | }
    defined class Variance
    
    scala> val vs = new Variance("String")
    vs: Variance[java.lang.String] = Variance[String]
    
    scala> val va: Variance[Any] = vs
    {console}:7: error: type mismatch;
     found   : Variance[java.lang.String]
     required: Variance[Any]
           val va: Variance[Any] = vs
                                   ^
!/sc!
                                                           *scala-covariance*
- Covariance: States that the type can be substituted by a type derived from
  the stated type.
!sc!
    scala> class Variance[+T](init: T) {
         |     val t: T = init
         |     override def toString = "Variance[" + t + "]"
         | }
    defined class Variance
    
    scala> val vs = new Variance("String")
    vs: Variance[java.lang.String] = Variance[String]
    
    scala> val va: Variance[Any] = vs
    va: Variance[Any] = Variance[String]
!/sc!
  Above we have a type {Variance[Any]} that we shove a {Variance[String]} in -
  i.e. the type we're putting in the {Any}'s place is a type that's derived
  from {Any}.
                                                       *scala-contravariance*
- Contravariance: States that the type can be be substituted by a type that is
  a superclass of the stated type.
!sc!
    scala> class OutputChannel[-T] {
         |     def write(t: T) = println(t)
         | }
    defined class OutputChannel
    
    scala> new OutputChannel[String].write("String") 
    String
    
    scala> new OutputChannel[Any].write("String".asInstanceOf[String])
    String
!/sc!
  Here we've got a base type and we're substituting something further down the
  hierarchy.


11.1.1 Type Variance Explained                *scala-variance-explained* {{{2
------------------------------------------------------------------------------

The simplest example of {covariance} and {contravariance} is the discussion of
{Function} traits.  If we take a look at the {Function1} trait, we see its
definition as:
!sc!
        trait Function1[-S, +T] {
            apply(x: S): T
        }
!/sc!
The argument is contravariant in {S} and the result is covariant in {T}.
Because the function itself will be instantiating the type represented by {T},
we know that the contract is held by the client.  The client is expecting a
{T} or a type derived from {T} and the Scala compiler will enforce that rule.

However, the argument type {S} is contravariant for the exact same reason in
the opposite direction.  Because the API is stating the contract on the type
but is not instantiating it, it is willing to expect an {S} but will also be
happy with something further down the inheritance hierarchy if the client
wishes to substitute it.

The following is a small example of covariance and contravariance without the
explicit statements by using {[+T]} and {[-S]} - we're not writing generic
code here.
!sc!
    class Publication(val title: String)
    class Book(title: String) extends Publication(title)

    object Library {
        val books: Set[Book] =
            Set(
                new Book("Programming in Scala"),
                new Book("Walden")
            )
        def printBookList(info: Book => AnyRef) {
            for (book <- books) println(info(book))
        }
    }

    object Customer extends Application {
        def getTitle(p: Publication): String = p.title
        Library.printBookList(getTitle)
    }
!/sc!
   argument type                                                result type
   -------------                                                -----------
       Book                 Book   =>   AnyRef                     AnyRef
        |                          ^                                  ^
        |                          |                                  |
        V                          |                                  |
   Publication       Publication   =>   String                     String


11.2 Lower Bound                                     *scala-lower-bound* {{{2
------------------------------------------------------------------------------

A lower bound states that a type must be a superclass of another type.  It's a
way of making certain things variant in the direction you need them to be when
those tend to be collection types.  The Queue is a decent example.
!sc!
    class Queue[+T] (private val leading: List[T],
                     private val trailing: List[T]) {
        private def mirror() = {
            if (leading.isEmpty) {
                while (!trailing.isEmpty) {
                    leading = trailing.head :: leading
                    trailing = trailing.tail
                }
            }
        }

        def head: T = {
            mirror()
            leading.head
        }

        def tail: Queue[T] = {
            mirror()
            new Queue(leading.tail, trailing)
        }

        def enqueue[U >: T](x: U) =
            new Queue[U](leading, x :: trailing)
    }
!/sc!
The lower bound on {enqueue} method states that it will accept a {U} typed
argument but that type must be a supertype of {T}.  This is a mechanism by
which the Queue can {enqueue} a new element that will result in the entire
Queue being recast from a Queue containing elements of type {T} to a Queue
containing elements of type {U}, which is legal because {T} inherits from {U}.


11.3 Upper Bound                                     *scala-upper-bound* {{{2
------------------------------------------------------------------------------

The upper bound is the inverse of the lower bound.  It's a mechanism by which
you can specify that a given type inherits from another given type.  A common
example of this is to specify that a type inherit from the {Ordered} type.
!sc!
    def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {
        def merge(xs: List[T], ys: List[T]): List[T] = {
            (xs, ys) match {
                case (Nil, _) => ys
                case (_, Nil) => xs
                case (x :: xs1, y :: ys1) =>
                    if (x < y) x :: merge(xs1, ys)
                    else y :: merge(xs, ys1)
            }
        }

        val n = xs.length / 2
        if (n == 0) xs
        else {
            val (ys, zs) = xs splitAt n
            merge(orderedMergeSort(ys), orderedMergeSort(zs))
        }
    }
!/sc!
Here we're passing in a {List[T]} but are stipulating that {T} must inherit
from {Ordered[T]} so that we can do some comparisons on it later.

11.4 Manifest Stuff                                      *scala-manifest* {{{2
------------------------------------------------------------------------------

This is pretty vague at the moment.  The JVM erases type information, which
makes it impossible for Scala to do some of the stuff it wants to do.  This is
very different than I've experienced in C++ with templates - I've just never
run into the situation where a "manifest" would be needed but with Scala it
appears to be needed a lot.

For example, the following was not possible -> I wanted to wrap up the
following calls into a helpful function (these are defined in |akka|,
specifically the |akka-actor-registry|):
!sc!
  val actors = registry.actorsFor[ChatClient]
  val mboxSize = (0 /: actors)((i, a) => i + a.mailboxSize)
!/sc!
It /looks/ like the type parameter is {ChatClient} but it's subtly different.
First of all, the {actorsFor} function has intelligently placed a
|scala-upper-bound| on the type parameter, so writing the following won't
work:
!sc!
  def mboxSize[A] = (0 /: registry.actorsFor[A])((i, a) => i + a.mailboxSize)
!/sc!
instead, we need to specify the upper bound for {A}:
!sc!
  def mboxSize[A <: akka.actor.ActorRef] =
    (0 /: registry.actorsFor[A])((i, a) => i + a.mailboxSize)
!/sc!
Now, the surprise (at least for my naive, young Scala mind) is that this
doesn't work either.  You get the following:
>
  could not find implicit value for parameter
  manifest: scala.reflect.Manifest[A]
<
Not exactly the most helpful error message in the world, especially when you
consider that the "Programming in Scala 2nd Edition" book does not mention the
manifest whatsoever.  So, it's not the {ChatClient} parameter that's the only
thing the compiler needs, it's the {ChatClient} and the manifest for
{ChatClient}.  Scala helps the library /user/ by providing a mechanism for
hiding that fact but it can't help the library /developer/ because the
developer must supply it implicitly.

I don't understand that details of the manifest entirely at this point but
suffice it to say that the compiler needs it and it can't just "get it" on its
own - it must be specified.  There are two ways to do this:

- The first is from pre-Scala 2.8 as an implicit parameter
  (|scala-implicit-parameters|).
!sc!
  def mboxSize[A <: akka.actor.ActorRef](implicit manifest: Manifest[A]) ...
!/sc!
  This is what the Akka source, in fact, already does (and I would have been
  wise to consult the source code of that before heading to Stack Overflow).

- The second way is to use Scala 2.8.x syntactic sugar:
!sc!
  def mboxSize[A <: akka.actor.Actor : Manifest] ...
!/sc!
  It compiles to the exact same thing (apparently) but it looks nicer, which
  is still pretty hideous, but this ugliness allows Scala to do something
  cool, so we forgive it.


==============================================================================
12. Pattern Matching                            *scala-pattern-matching* {{{1
------------------------------------------------------------------------------

Pattern matching does not refer to {regex} pattern matching.  Pattern matching
here is within the context of a functional language, and certainly ain't new.
In Scala it's implemented using instances of {case} classes.

12.1 Case Classes                                   *scala-case-classes* {{{2
------------------------------------------------------------------------------

In the simplest of terms, a {case} class is a regular class that is prefixed
with the keyword "case".  The following are {case} classes:
!sc!
    abstract class Expr
    case class Var(name: String) extends Expr
    case class Number(num: Double) extends Expr
    case class UnOp(operator: String, arg: Expr) extends Expr
    case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
!/sc!
The keyword {case} is put there by the Scala compiler in order to optimize a
few things:

- the requirement for the {new} keyword is eliminated.  Object factories are
  immediately created that allow you to construct instances very easily:
!sc!
    val variable = Var("a variable")
!/sc!
- as well, all of the elements in the parameter list get a {val} prefix and
  become maintained fields:
!sc!
    scala> variable.name
    res0: String = a variable
!/sc!
- you also get natural implementations of {toString}, {hashCode} and {equals}.
  These will happily work recursively through whatever nested {case} classes
  they find.
!sc!
    scala> val op = BinOp("+", Number(1), v)
    op: BinOp = BinOp(+,Number(1.0),Var(x))

    scala> println(op)
    BinOp(+,Number(1.0),Var(x))

    scala> op.right == Var("a variable")
    res0: Boolean = true
!/sc!
- as well, the {copy} method is also created for you, and allows for you to
  specify changes using named parameters.  Anything that isn't specified is
  copied from the original.  As an example, we can copy the {BinOp} object and
  change the operation.
!sc!
    scala> op.copy(operator = "-")
    res0: BinOp = BinOp(-,Number(1.0),Var(x))
!/sc!

12.2 Basic Pattern Match                     *scala-basic-pattern-match* {{{2
------------------------------------------------------------------------------

Working from what's previously defined, we can simplify expressions that
cancel each other out with this function definition:
                                                         *scala-simplify-top* !sc!
    def simplifyTop(expr: Expr): Expr = expr match {
        case UnOp("-", UnOp("-", e)) => e // Double negation
        case BinOp("+", e, Number(0)) => e	// Adding zero
        case BinOp("*", e, Number(1)) => e	// Multiplying by one
        case _ => expr // Can't be simplified
    }
!/sc!

12.3 Comparison to Java Switch                   *scala-match-vs-switch* {{{2
------------------------------------------------------------------------------

- Different syntax:
!sc!
    switch (selector) { alternatives }

vs

    selector match { alternatives }
!/sc!
- A {match} is an {expression} in Scala, not just a statement.  This means
  that it will always return a value.

- Scala's alternative expressions never "fall through" to the next
  alternative.

- If you get to the end of alternatives and nothing matched then a
  {MatchError} will be thrown.


12.4 Wildcards                                   *scala-match-wildcards* {{{2
------------------------------------------------------------------------------

The "_" character matches anything and you can use it to ignore parts of a
pattern if you want.  If you want to match structure but not care what's in
that structure, just do this:
!sc!
    expr match {
        case BinOp(_, _, _) => println(expr + " is a binary expression")
        case _ => println("It's a non-binary expression")
    }
!/sc!

12.5 Constant Patterns                         *scala-constant-patterns* {{{2
------------------------------------------------------------------------------

You don't have to use constructed objects to match on, you can use constants
as well.  A constant will only match itself, it won't match any magically
constructed object.
!sc!
    def describe(x: Any) = x match {
        case 5       => "five"
        case true    => "truth"
        case "hello" => "hi!"
        case Nil     => "the empty list"
        case _       => "something else"
}
!/sc!

12.6 Variable Patterns                         *scala-variable-patterns* {{{2
------------------------------------------------------------------------------

Just as with the "_" wildcard, you can have a variable pattern match, which is
exactly the same idea but gives a symbol to the "anything" that gets matched.
!sc!
    expr match {
        case 0 => "zero"
        case somethingElse => "not zero: " + somethingElse
    }
!/sc!
The {somethingElse} is the variable we've used to match anything at all and
give it a symbol we can grab on to.

The difference between a {constant} and a {variable} pattern is pretty simple
to Scala - a {constant} pattern is assumed to start with an upper case letter
while a {variable} expression is assumed to start with a lower case letter.

Here's the idea:
!sc!
    scala> val pi = math.Pi
    pi: Double = 3.141592653589793

    scala> E match {
         |     case pi => "strange math? Pi = " + pi
         | }
    res0: java.lang.String = strange math? Pi = 2.718281828459045
!/sc!
Scala has matched against the variable pattern specification "pi" instead of
matching against its value; that's not the goal here.

If you really want to use a lower case symbol for a constant, you can put it
in some sort of context, such as an object:
!sc!
    scala> object Obj { val pi = math.Pi }
    scala> E match {                                 
         |     case Obj.pi => "strange math? Pie = " + Obj.pi
         |     case _ => "OK"
         | }
    res0: java.lang.String = OK
!/sc!

12.7 Constructor Patterns                   *scala-constructor-patterns* {{{2
------------------------------------------------------------------------------

Constructor patterns are where the sex is when it comes to pattern matching.
Matching against case classes allows for deep matching, where the constructor
matched against may have constructors you can match against, which can have
constructors, etc... sweetness.

                                                   *scala-sequence-patterns*

If we want to match against a {List} where the first element in the {List} is
"0" and the {List} has three elements in it, we can do something like this:
!sc!
    expr match {
        case List(0, _, _) => println("found it")
        case _ =>
    }
!/sc!
                                   *scala-variable-length-sequence-patterns*

If you want to match against any length of sequence then you can use the
special "_*" symbol.
!sc!
    scala> List(0, 1, 2, 3, 4, 5) match {
         |    case List(0, _*) => println("found it")
         |    case _ =>
         | }
    found it
!/sc!                                                     *scala-tuple-patterns*

You can match against arbitrary tuples as well as can be seen from the
following example:
!sc!
    scala> def tupleDemo(expr: Any) = expr match {
         |     case (a, b, c) => println("matched " + a + b + c)
         |     case _ =>
         | }
    tupleDemo: (expr: Any)Unit
    
    scala> tupleDemo(("a ", 3, "-tuple"))
    matched a 3-tuple
!/sc!

12.8 Typed Patterns                               *scala-typed-patterns* {{{2
------------------------------------------------------------------------------

Typed patterns are the other area where things get cool.  A simple example of
this is:
!sc!
    scala> def generalSize(x: Any) = x match {
         |     case s: String => s.length
         |     case m: Map[_, _] => m.size
         |     case _ => -1
         | }
    generalSize: (x: Any)Int
    
    scala> generalSize("abc")
    res0: Int = 3
    
    scala> generalSize(Map(1 -> 'a', 2 -> 'b'))
    res1: Int = 2
    
    scala> generalSize(math.Pi)
    res2: Int = -1
!/sc!

12.9 Type Erasure                                   *scala-type-erasure* {{{2
------------------------------------------------------------------------------

Scala uses the erasure model for generics just like Java does.  This means
that doing the following is pretty tough:
!sc!
    scala> def isIntIntMap(x: Any) = x match {
         |     case m: Map[Int, Int] => true
         |     case _ => false
         | }
    warning: there were unchecked warnings;
             re-run with -unchecked for details
             isIntIntMap: (x: Any)Boolean
!/sc!
So we re-run this with {-unchecked} turned on:
!sc!
    scala> :quit
    $ scala -unchecked
    Welcome to Scala version 2.8.1
    (Java HotSpot(TM) Client VM, Java 1.5.0_13).
    Type in expressions to have them evaluated.
    Type :help for more information.

    scala> def isIntIntMap(x: Any) = x match {
         |     case m: Map[Int, Int] => true
         |     case _ => false
         | }
    {console}:5: warning: non variable type-argument Int in
                 type pattern is unchecked since it is eliminated
                 by erasure
          case m: Map[Int, Int] => true
                  
!/sc!
This yields the following surprising results:
!sc!
    scala> isIntIntMap(Map(1 -> 1))
    res0: Boolean = true

    scala> isIntIntMap(Map("abc" -> "abc"))
    res1: Boolean = true
!/sc!

12.10 Variable Binding                          *scala-variable-binding* {{{2
------------------------------------------------------------------------------

When you want to reference the thing you matched you might need to use the "@"
symbol.
!sc!
    expr match {
        case UnOp("abs", e @ UnOp("abs", _)) => e
        case _ =>
    }
!/sc!
Note how we can use {e} above and its matching the !sc!UnOps("abs", _))!/sc!.


12.11 Pattern Guards                              *scala-pattern-guards* {{{2
------------------------------------------------------------------------------

Let's say you want to do this:
!sc!
    scala> def simplifyAdd(e: Expr) = e match {
         |     case BinOp("+", x, x) => BinOp("*", x, Number(2))
         |     case _ => e
         | }
!/sc!
Well, you can't.  Scala requires that the pattern itself be linearized and
that symbols within it can only appear once.  In order to do what you want,
where you want to see a duplication, you have to put a guard in place.
!sc!
    scala> def simplifyAdd(e: Expr) = e match {
         |     case BinOp("+", x, y) if x == y => BinOp("*", x, Number(2))
         |     case _ => e
         | }
!/sc!
It's the "!sc!if x == y!/sc!" that we're talking about here.  The failure to
match the entire pattern, including the guard(s) will make it test the next
pattern alternative.

Some other examples:
!sc!
    // match only positive integers
    case n: Int if 0 < n => ...
    
    // match only strings starting with the letter a
    case s: String if s(0) == 'a' => ...
!/sc!

12.12 Pattern Overlaps (Depth)                  *scala-pattern-overlaps* {{{2
------------------------------------------------------------------------------

The |scala-simplify-top| example above does a single level match on what it
finds and tries to simplify it.  However, that's pretty naive because these
expressions could get quite deep.  We can perform pattern overlapping and deep
recursion to perform the simplification.
!sc!
    def simplifyAll(expr: Expr): Expr = expr match {
        case UnOp("-", UnOp("-", e)) =>
            // Just ditch the rest as they cancel each other out
            simplifyAll(e)
        case BinOp("+", e, Number(0)) =>
            // '0' is a neutral element for '+'
            simplifyAll(e)
        case BinOp("*", e, Number(1)) =>
            // '1' is a neutral element for '*'
            simplifyAll(e)
        case UnOp(op, e) =>
            UnOp(op, simplifyAll(e))
        case BinOp(op, l, r) =>
            BinOp(op, simplifyAll(l), simplifyAll(r)
        case _ => expr
    }
!/sc!
Note that the more specific cases come before the more general cases.  This is
critical, of course, in order to match things properly.  If we put the general
cases first then we'd match those and never reach the more specific cases that
we took the effort to write in the first place.

If we're actually this stupid, then the compiler will stop us in our tracks,
so it saves us from ourselves.


12.13 Sealed Classes                              *scala-sealed-classes* {{{2
------------------------------------------------------------------------------

Sealed classes provide a mechanism for protection given by the Scala compiler
to the programmer.  The compiler can't know how many case classes may exist
for a particular set of possibilities - you can always add another derivation
of a base class in any other file at any time and then throw that at a pattern
match.  A sealed class must see all derivations within the same file, so if
you declare your case classes' base class as a {sealed} class then the
compiler will guarantee that all of the derivations are visible within that
specific translation unit.
!sc!
    sealed abstract class Expr
    case class Var(name: String) extends Expr
    case class Number(num: Double) extends Expr
    case class UnOp(operator: String, arg: Expr) extends Expr
    case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
!/sc!
The compiler will tell you if you're missing something, like this:
!sc!
    scala> def describe(e: Expr): String = e match {
         |     case Number(_) => "a number"
         |     case Var(_)    => "a variable"
         | }
    warning: match is not exhaustive!
    missing combination	UnOp
    missing combination	BinOp
!/sc!
If you know that the warning is benign and want to shut it up, there are two
methods:

Toss in a catch-all:
!sc!
    scala> def describe(e: Expr): String = e match {
         |     case Number(_) => "a number"
         |     case Var(_)    => "a variable"
         |     case _ => throw new RuntimeException // Shouldn't happen
         | }
!/sc!
Toss in an annotation:
!sc!
    scala> def describe(e: Expr): String = (e: @unchecked) match {
         |     case Number(_) => "a number"
         |     case Var(_)    => "a variable"
         |     case _ => throw new RuntimeException // Shouldn't happen
         | }
!/sc!

12.14 Patterns in Variable Definitions     *scala-patterns-in-variables* {{{2
------------------------------------------------------------------------------

                                                 *scala-pulling-apart-tuples*
Pattern matching is used when pulling tuples apart:
!sc!
    scala> val myTuple = (123, "abc")
    myTuple: (Int, java.lang.String) = (123,abc)

    scala> val (number, string) = myTuple
    number: Int = 123
    string: java.lang.String = abc
!/sc!
You can also pull apart a {case} class explicitly:
!sc!
    scala> val exp = new BinOp("*", Number(5), Number(1))
    exp: BinOp = BinOp(*,Number(5.0),Number(1.0))

    scala> val BinOp(op, left, right) = exp
    op: String = *
    left: Expr = Number(5.0)
    right: Expr = Number(1.0)
!/sc!

12.15 Patterns and Partial Functions       *scala-patterns-and-partials* {{{2
------------------------------------------------------------------------------

A list of pattern alternatives may not be exhaustive - i.e. it may not handle
all possible cases, with the obvious thing being that it may not have a
!sc!{ case _ => _ }!/sc! alternative in it.  When the list is not exhaustive,
we have a partial function.

Scala does not really detect these, per se.  You can define them literally by
doing something like the following:
!sc!
    val second: PartialFunction[List[Int], Int] = {
        case x :: y :: _ => y
    }
!/sc!
The above is partial by definition since it, at the very least, doesn't handle
the case of an empty {List}.  But by stating that it is a {PartialFunction} we
are telling Scala something important.  It will now be able to provide a
mechanism by which code can interrogate it for information about where it's
defined.

What the compiler does is essentially create a construct that looks like the
following:
!sc!
    new PartialFunction[List[Int], Int] {
        def apply(xs: List[Int]) = xs match {
            case x :: y :: _ => y
        }
        def isDefinedAt(xs: List[Int]) = xs match {
            case x :: y :: _ => true
            case _ => false
        }
    }
!/sc!
The point being that now we can interrogate the object an ask it if it's
defined for certain inputs:
!sc!
    scala> second.isDefinedAt(List(5,6,7))
    res0: Boolean = true

    scala> second.isDefinedAt(List())
    res1: Boolean = false
!/sc!
It's generally a good idea to stick with complete functions whenever you can
because this type of flexibility would generally result in more runtime
errors.  There are two code paths you could write to deal with a partial
function, and only one of them is arguably any good - but it's still a pain to
write.

First:!sc!
    if (second.isDefinedAt(List())
        second(List())
    else
        // do something intelligent
!/sc!
And second:!sc!
    second(List()) // Oops
!/sc!

12.16 Extractors                             *scala-patterns-extractors* {{{2
------------------------------------------------------------------------------

Extractors take the form of {unapply} and {unapplySeq} methods on objects.  A
simple example is:
!sc!
    object Email {
        def unapply(addr: String) = {
            val parts = addr.split("@")
            if (parts.length == 2) Some(parts(0), parts(1)) else None
        }
    }

    scala> val myEmail = "derek@derekwyatt.org"
    myEmail: java.lang.String = derek@derekwyatt.org

    scala> myEmail match {
         |     case Email(userId, domain) =>
         |         println(userId + " - (at) - " + domain)
         | }
    derek - (at) - derekwyatt.org
!/sc!
and it works using an {Any} as well
!sc!
    scala> val myAnyEmail: Any = "derek@derekwyatt.org"
    myEmail: Any = derek@derekwyatt.org

    scala> myAnyEmail match {
         |     case Email(userId, domain) =>
         |         println(userId + " - (at) - " + domain)
         | }
    derek - (at) - derekwyatt.org
!/sc!

12.16.1 Deeper Extracting                      *scala-deeper-extracting* {{{3
------------------------------------------------------------------------------

Given the following extractors (with some defined, but not required
{injectors}):
!sc!
    object Email {
        def apply(userId: String, domain: String) = userId + "@" + domain
        def unapply(addr: String) = {
            val parts = addr.split("@")
            if (parts.length == 2) Some(parts(0), parts(1)) else None
        }
    }

    object Twice {
        def apply(s: String): String = s + s
        def unapply(s: String): Option[String] = {
            val length = s.length / 2
            val half = s.substring(0, length)
            if (half == s.substring(length)) Some(half) else None
        }
    }

    object UpperCase {
        def unapply(s: String): Boolean = s.toUpperCase == s
    }
!/sc!
we can create the following pattern matcher:
!sc!
    def userTwiceUpper(s: String) = s match {
        case Email(Twice(x @ UpperCase()), domain) =>
            "match: " + x + " in domain " + domain
        case _ =>
            "no match"
    }

    scala> userTwiceUpper("derek@derekwyatt.org")
    res0: java.lang.String = no match
    
    scala> userTwiceUpper("DEREK@derekwyatt.org")
    res1: java.lang.String = no match

    scala> userTwiceUpper("DIDI@derekwyatt.org") 
    res2: java.lang.String = match: DI in domain derekwyatt.org
!/sc!
It's important to understand how the matching is taking place.  We match
backwards to what you think we might.  Normally we would evaluate {UpperCase},
then evaluate {Twice} and then evaluate {Email}, but it happens backwards in
this case.

- First we match to Email,
  - Then we match inside Email against something that happens Twice
    - Then we match in against the UpperCase

Note that we use the "@" syntax to bind {x} variable to what {UpperCase}
matched so we can use it later.


12.16.2 Variable Arg Extractors          *scala-variable-arg-extractors* {{{3
------------------------------------------------------------------------------

In order to extract variable arguments we need to implement the {unapplySeq}
instead of the {unapply} function.  If we want to extract a fully qualified
domain name, for example, we could do this:
!sc!
    object Domain {
        def apply(parts: String*): String = parts.reverse.mkString(".")
        def unapplySeq(whole: String): Option[Seq[String]] =
            Some(whole.split("\\.").reverse)
    }

    scala> "api.scala-lang.org" match {
         |     case Domain(a, b, c) => println(a + "." + b + "." + c)
         | }
    org.scala-lang.api

    scala> "api.scala-lang.org" match {
         |     case Domain(a, b) => println(a + "." + b)
         |     case _ => println("no match")
         | }
    no match

    scala> "api.scala-lang.org" match {
         |     case Domain(a, _*) => println(a)
         |     case _ => println("no match")
         | }
    org

    scala> "api.scala-lang.org" match {
         |     case Domain(a, rest @ _*) => println(a + "\n" + rest)
         | }
    org
    WrappedArray(scala-lang, api)
!/sc!

==============================================================================
13. Language Extensibility                         *scala-extensibility* {{{1
------------------------------------------------------------------------------

13.1 Implementing loop/unless                       *scala-loop-unless* {{{2
------------------------------------------------------------------------------

This is just friggin' cool but it's not exactly intuitive for me at this point
so it requires some serious explanation.  I pulled this from:
http://www.scala-lang.org/node/138

Here's the construct we're going for:
!sc!
    var i = 10
    loop {
        println("i = " + i)
        i -= 1
    } unless (i == 0)
!/sc!
Now, here's how we make it happen.
!sc!
    object LoopConstruct {
        def loop(body: => Unit): LoopUnlessCond =
            new LoopUnlessCond(body)
    
        protected class LoopUnlessCond(body: => Unit) {
            def unless(cond: => Boolean) {
                body
                if (!cond) unless(cond)
            }
        }
    }

    // Import the elements of the object so that we
    // can make use of it as the goal requires
    import LoopConstruct._
!/sc!
This is pretty easy to figure out, but I wouldn't be able to build it myself
at this point.  The key point is that we present to the user, the main goal
function, {loop}.  The publicly available {loop} function takes a "by name"
parameter called {body} that doesn't return anything.  If that's all there was
then it would satisfy something like this:
!sc!
    var i = 10
    loop {
        println("i = " + i)
        i -= 1
    }
!/sc!
What we need to make happen is to pass the block of code to something that
will manage it conditionally with the {unless} condition.  We do that by
returning a new object, but this object is not directly constructable by the
user.  Once it's constructed, however, the methods are easily accessible.
It's this new object (of class {LoopUnlessCond}) that actually executes our
code - it has the {unless} method.

Essentially, the {loop} method is a {factory} method that constructs the
runtime code held in {LoopUnlessCond}.  The {LoopUnlessCond} holds on to the
code block that is passed to {loop} and the resulting object gives access to
the {unless} method that executes the code in a Tail Recursive
(|scala-tail-recursion|) manner.

Assuming we could construct the {LoopUnlessCond} object directly, we can
illustrate what the {factory} code is actually doing:
!sc!
    var i = 10
    val unlessCode = new LoopUnlessCond({
        println("i = " + i)
        i -= 1
    })
    unlessCode.unless(i == 0)
!/sc!
However, that looks like absolute crap.  Scala's infix notation makes it
possible to create real control constructs that look like true extensions of
the language instead of simple library additions.


==============================================================================
14. Functional Programming                            *scala-functional* {{{1
------------------------------------------------------------------------------

This section will try and illuminate some examples on how to convert
imperative style programming into functional style programming.

14.1 Printing a Matrix                         *scala-functional-matrix* {{{2
------------------------------------------------------------------------------
!sc!
    def printMultiTable() {
        var i = 1

        while (i <= 10) {
            var j = 1

            while (j <= 10) {
                val prod = (i * j).toString

                var k = prod.length

                while (k < 4) {
                    print(" ")
                    k += 1
                }
                print(prod)
                j += 1
            }
            println()
            i += 1
        }
    }
!/sc!
We can refactor this imperative-style code into functional style code with the
following implementation:
!sc!
    def makeRowSeq(row: Int) =
        for (col <- 1 to 10) yield {
            val prod = (row * col).toString
            val padding = " " * (4 - prod.length)
            padding + prod
        }

    def makeRow(row: Int) = makeRowSeq(row).mkString

    def multiTable() = {
        val tableSeq = for (row <- 1 to 10) yield makeRow(row)
        tableSeq.mkString("\n")
    }
!/sc!
And, what this does, in either case is:
!sc!
   1   2   3   4   5   6   7   8   9  10
   2   4   6   8  10  12  14  16  18  20
   3   6   9  12  15  18  21  24  27  30
   4   8  12  16  20  24  28  32  36  40
   5  10  15  20  25  30  35  40  45  50
   6  12  18  24  30  36  42  48  54  60
   7  14  21  28  35  42  49  56  63  70
   8  16  24  32  40  48  56  64  72  80
   9  18  27  36  45  54  63  72  81  90
  10  20  30  40  50  60  70  80  90 100
!/sc!

==============================================================================
15. Testing                                              *scala-testing* {{{1
------------------------------------------------------------------------------

Scala code is Java code, so the JUnit 3 and 4 testing frameworks
(http://www.junit.org/) inter-operate with Scala quite well, as does the
TestNG (http://testng.org) framework.  However, it looks like the best thing
to do at the moment is to, at least, use the ScalaTest framework
(http://scalatest.org/).

As far as I can tell, the most straight forward way to go is something like
the following: !sc!

    import org.scalatest.FlatSpec
    import org.scalatest.matchers.ShouldMatchers
    import Element.elem

    class ElementSpec extends FlatSpec with ShouldMatchers {
        "A UniformElement"
        should "have a width equal to the passed value" in {
            val ele = elem('x', 2, 3)
            ele.width should be (2)
        }
        it should "have a height equal to the passed value" in {
            val ele = elem('x', 2, 3)
            ele.height should be (3)
        }
        it should "throw an IAE if passed a negative width" in {
            evaluating {
                elem('x', -2, 3)
            } should produce [IllegalArgumentException]
        }
    }
!/sc!
                                                           *scala-scalacheck*

Beyond that, there's something I should try at some point - ScalaCheck
(http://code.google.com/p/scalacheck/).  ScalaCheck can generate test data and
drive that through your code based on a specification that you toss in.
!sc!
    import org.scalatest.WordSpec
    import org.scalatest.prop.Checkers
    import org.scalacheck.Prop._
    import Element.elem

    class ElementSpec extends WordSpec with Checkers {
        "elem result" must {
            "have passed width" in {
                check((w: Int) => w > 0 ==> (elem('x', 2, w).width == w))
            }
            "have passed height" in {
                check((h: Int) => h > 0 ==> (elem('x', 2, h).height == h))
            }
        }
    }
!/sc!

==============================================================================
16. Miscellaneous                                  *scala-miscellaneous* {{{1
------------------------------------------------------------------------------

16.1 Unicode                                             *scala-unicode* {{{2
------------------------------------------------------------------------------

Anywhere you need to, you can specify a unicode character with "\u{code}".
This example should do it all:
!sc!
    scala> val B\u0041\u0044 = 1
    BAD: Int = 1
!/sc!

16.2 Working with Collections                    *scala-collection-tips* {{{2
------------------------------------------------------------------------------

                                                     *scala-using-listbuffer*
Constructing a {List} may be expensive depending on how you can do it and if
it's getting expensive because you're having to do it all piecemeal and such,
it may be necessary to use a {ListBuffer}.
!sc!
    scala> import scala.collection.mutable.ListBuffer
    import scala.collection.mutable.ListBuffer

    scala> val buf = new ListBuffer[Int]
    buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()

    scala> buf += 1
    res1: buf.type = ListBuffer(1)

    scala> buf += 2
    res2: buf.type = ListBuffer(1, 2)

    scala> buf
    res3: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)

    scala> 3 +=: buf
    res4: buf.type = ListBuffer(3, 1, 2)

    scala> buf.toList
    res5: List[Int] = List(3, 1, 2)
!/sc!
You may also want to use it to avoid a stack overflow.  If you could build the
{List} using standard means, by prepending everything but there are a ton of
elements and you can't do it in a tail recursive manner, it may be better to
iterate it and use a {ListBuffer} instead.


16.3 Implicit Conversions                   *scala-implicit-conversions* {{{2
------------------------------------------------------------------------------

Implicit conversions are somewhat like we see in C++ except there's a bit more
power in Scala.


16.3.1 Converting on the Source          *scala-implicit-source-convert* {{{2
------------------------------------------------------------------------------

This is the simple C++ route of doing things.  Implicit conversions on the
source object occur in a number of situations:

- When the object type being passed in to a function is not the right type

- When the value / variable type being assigned to is not the right type

- When the return value from a function is not the right type

It's pretty simple:
!sc!
    val d: Double = 5
    val d: Double = thisReturnsADouble(5)
    val x = thisRequiresADouble(5)
!/sc!
In Java and C++ the upcast from {Int} to {Double} is part of the language, but
in Scala it's not - it's just another library specification.  The definition
exists in {Predef}:
!sc!
    object Predef {
        implicit int2double(x: Int) : Double = x.toDouble
    }
!/sc!
... or something like that :)


16.3.2 Converting on the Receiver      *scala-implicit-receiver-convert* {{{2
------------------------------------------------------------------------------

This is where Scala beats C++.  Scala can convert an object from type {X} to
type {Y} if the method being called on {X} does not exist, but it does exist
on {Y}, and {Y} has the method we're looking for.  The {->} operator for map
association is a good example of this.  Defined in |scala-preamble| it
converts the left-hand side object to type {ArrowAssoc} in order to take
advantage of the {->} operator within it.
!sc!
    package scala

    object Predef {
        class ArrowAssoc[A](x: A) {
            def -> [B](y: B): Tuple2[A, B] = Tuple2(x, y)
        }

        implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
            new ArrowAssoc(x)
    }
!/sc!
When the compiler sees something like ("One" -> 1) it scans the object of type
{java.lang.String} to see if it has a method called {->} and it finds that it
doesn't.  It doesn't give up yet, though... it looks through the list of
{implicit} conversions that are currently in scope and finds all the class
types that can be converted to.  It then searches linearly through that list
to find the first one that has an appropriate method on it; in this case the
method is {->}, and it finds that the {ArrowAssoc} class is the class that
does it.  So it then converts from the {java.lang.String} to {ArrowAssoc} to
do the conversion.

The compiler generates the following code:
!sc!
    // This is what the coder wrote in
    val map = Map("One" -> 1, "Two" -> 2)

    // And the Scala compiler converted to this
    val map = Map(any2ArrowAssoc("One").->(1),
                  any2ArrowAssoc("Two").->(2))
!/sc!

16.3.3 Implicit Parameters                   *scala-implicit-parameters* {{{2
------------------------------------------------------------------------------

Implicit parameters aren't what I originally thought... they're not the
implicit conversions that occur when passing parameters with incorrect types
to functions; they're curried function parameters that, if not provided are
supplied from implicit objects defined using the same scoping rules as for
other implicits.

The simple example is the following:
!sc!
    class PreferredPrompt(val preference: String)

    object DereksPrefs {
        implicit val prompt = new PreferredPrompt("make it happen> ")
    }

    object Greeter {
        def greet(name: String)(implicit prompt: PreferredPrompt) {
            println("Welcome, " + name + ". The system is ready.")
            println(prompt.preference)
        }
    }

    scala> Greeter.greet("Derek")
    Welcome, Derek. The system is ready.
    make it happen> 
!/sc!
However, there's a more interesting example that brings out a language
construct.
!sc!
    def maxListUpBound[T <: Ordered[T]](elements: List[T]): T =
        elements match {
            case List() =>
                throw new IllegalArgumentException("empty list")
            case List(x) => x
            case x :: rest =>
                val maxRest = maxListUpBound(rest)
                if (x > maxRest) x
                else maxRest
        }
!/sc!
The problem with the above is that it doesn't work with a ton of stuff, only
those things that inherit from, or mix in {Ordered[T]} and not everything does
that; specifically {Int} doesn't work with {Ordered[T]} in that way.

What would be better is to pass in a function that orders the elements:
!sc!
    def maxListUpBound(elements: List[T])(implicit orderer: T => Ordered[T]): T =
        elements match {
            case List() =>
                throw new IllegalArgumentException("empty list")
            case List(x) => x
            case x :: rest =>
                val maxRest = maxListUpBound(rest)(orderer)
                if (orderer(x) > maxRest) x
                else maxRest
        }
!/sc!
Note that the {orderer} function is used to create a type that will allow for
comparisons against the elements of the {List}.  And the {orderer} function is
implicit so one doesn't necessarily need to supply it.  Scala defines a number
of implicits that will convert various types to something compatible with
{Ordered[T]}.  For things that already support {Ordered[T]}, Scala will use
the identity function:
!sc!
    implicit def identity[A](x: A): A = x
!/sc!
                                                           *scala-view-bound*
However, this isn't as sexy as one might like.  The original example that
included the upper bound is preferable.  This opens the door for a new
language construct called the "view bound".
!sc!
    def maxListUpBound[T <% Ordered[T]](elements: List[T]): T =
        elements match {
            case List() =>
                throw new IllegalArgumentException("empty list")
            case List(x) => x
            case x :: rest =>
                // (orderer) is implicit
                val maxRest = maxListUpBound(rest)
                // orderer(x) is implicit
                if (x > maxRest) x
                else maxRest
        }
!/sc!
The interesting bit here is that we have replaced the {<:} with a {<%},
signifying that we have moved from the upper bound to a view bound.  The view
bound will attempt to find an implicit conversion that makes {T} operable in
the code.

The other interesting point is that (obviously) we don't need {orderer}
anymore, but we really never did.  Because the implicit parameter was
implicit, the compiler would always substitute it where it needs to be so it
actually was never needed in the first place, so we could have written this:
!sc!
    def maxListUpBound(elements: List[T])(implicit orderer: T => Ordered[T]): T =
        elements match {
            case List() =>
                throw new IllegalArgumentException("empty list")
            case List(x) => x
            case x :: rest =>
                // (orderer) is implicit
                val maxRest = maxListUpBound(rest)
                // orderer(x) is implicit
                if (x > maxRest) x
                else maxRest
        }
!/sc!
Now, we don't have to worry about anything else since we have specified the
{<%}.


16.3.4 Implicits and Rules                        *scala-implicit-rules* {{{2
------------------------------------------------------------------------------

The following rules apply to finding and using implicits:

- Only definitions marked with the keyword {implicit} are available

- An inserted implicit conversion must be in scope as a single identifier, or
  be associated with the source or target type of the conversion

- Only one implicit is tried (i.e. it won't chain them to try and get the
  right type - just one level)

- Explicits come first.  Whenever code type checks as it is written, no
  implicits are attempted

- Names for implicit conversions can be anything but should be descriptive to
  assist in direct importing and direct calling

- There are three places that implicits are tried:
  - conversions to an expected type
  - conversions of the reciever of a selection
  - implicit parameters

Looser rules / style rules

- Don't be vague. e.g. If you have an implicit parameter, don't make the
  parameter a {String} or something equally vague.  Make the parameter a
  specific and clear type, such as {PreferredCommandLinePrompt}.  This makes
  it next to impossible for the compiler to get confused on.

Ambiguity resolution

- If multiple matches for an implicit are possible then the same rules apply
  as for function overloads.  The compiler will choose the more specific
  version.  An example is mose illustrative here:
!sc!

    class Base
    class Derived extends Base
    
    implicit def base2int(x: Base) : Int = 5
    implicit def derived2int(x: Derived) : Int = 10
    
    scala> var i1: Int = new Base
    i1: Int = 5

    scala> var i2: Int = new Derived
    i1: Int = 10
!/sc!
The compiler /could/ have chosen the {base2int} implicit definition above for
{i2} but there was a more specific version available so it chose {derived2int}
instead.

- There's another specialization that also removes ambiguity.  An implicit
  defined lower down in a hierarchy takes precedence over one higher up.
!sc!
    class Base
    class Higher {
        implicit def base2int(x: Base) : Int = 5
    }
    object Lower extends Higher {
        implicit def myBase2int(x: Base) : Int = 10
    }

    scala> import Lower._
    scala> var i: Int = new Base
    i: Int = 10
!/sc!
There are two independent functions that convert instances of {Base} to {Int}
but the compiler prefers the definition specific to {object} {Lower} because
it's further down in the hierarchy.


16.3.5 Debugging Implicits                    *scala-implicit-debugging* {{{2
------------------------------------------------------------------------------

Because implicits are so flexible, things can get hairy, just like with C++.
There are few ways to debug these issues:

- If an implicit conversion you think should be happening isn't actually
  happening, try do it explicitly and see what happens.
!sc!
    scala> val chars: List[Char] = "xyz"
    {console}:5: error: type mismatch;
     found   : java.lang.String("xyz")
     required: List[Char]
           val chars: List[Char] = "xyz"
                                   ^
!/sc!
  This says that there's something more wrong than you might think... either
  - the function hasn't been written
  - hasn't been written properly (e.g. has the wrong type)
  - isn't imported into the right scope

- Try calling the implicit conversion function explicitly.
!sc!
    scala> val chars: List[Char] = wrapString("xyz")
    {console}:5: error: type mismatch;
     found   : scala.collection.immutable.WrappedString
     required: List[Char]
           val chars: List[Char] = wrapString("xyz")
                                             ^
!/sc!
  {wrapString} converts to {WrappedString} and not {List[Char]} so the
  explicitly called conversion doesn't work.

- Compile the code again using the {-Xprint:typer} flag.  It will spit out
  what the code looks like after the compiler has shoved in the implicits that
  it has decided to shove in there.  This is probably most appropriate when a
  conversion happens that you weren't expecting.
!sc!
    object Mocha extends Application {
        class PreferredDrink(val preference: String)
        implicit val pref = new PreferredDrink("mocha")
        def enjoy(name: String)(implicit drink: PreferredDrink) {
            print("Welcome, " + name)
            print(". Enjoy a ")
            print(drink.preference)
            println("!")
        }
        enjoy("reader")
    }
!/sc!
$ scalac -Xprint:typer mocha.scala

 (FYI: I put the <...> guys in double quotes to
  fix the syntax highlighting problem.  The
  syntax highlighter things these are XML tags)
!sc!
    [[syntax trees at end of typer]]// Scala source: mocha.scala
    package "<empty>" {
        final object Mocha extends java.lang.Object with Application
            with ScalaObject {
            // ...
            private[this] val pref: Mocha.PreferredDrink =
                new Mocha.this.PreferredDrink("mocha");
            implicit "<stable>" "<accessor>"
                def pref: Mocha.PreferredDrink = Mocha.this.pref;
            def enjoy(name: String)
                    (implicit drink: Mocha.PreferredDrink): Unit = {
                scala.this.Predef.print("Welcome, ".+(name));
                scala.this.Predef.print(". Enjoy a ");
                scala.this.Predef.print(drink.preference);
                scala.this.Predef.println("!")
            };
            Mocha.this.enjoy("reader")(Mocha.this.pref)
        }
    }
!/sc!

==============================================================================
Modelines: {{{1
vim:tw=78:ts=4:ft=help:fdm=marker:fdl=0
